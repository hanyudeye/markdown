
- 注册账号，登录
- 服务号，每个服务号可以创建10个主体小程序和3个非主体小程序
- 开发工具IDE
- 预览权限 添加成员或添加体验成员


 特点  
- 没有DOM
- 组件化开发；具备特定功能效果的代码集合
- 适配方案 rpx(responsive pixel 响应式像素单位) 750rpx [全是手机屏幕,电脑上也是]

* 小程序配置
** sitemap.json 页面索引文件 
 配置小程序及其页面是否允许被微信索引
*** 配置 path/to/page 页面被索引，其余页面不被索引
   #+BEGIN_EXAMPLE
       {
         "rules":[{
           "action": "allow",
           "page": "path/to/page"
         }, {
           "action": "disallow",
           "page": "*"
         }]
       }
   #+END_EXAMPLE

* 小程序
** 框架
*** 逻辑层 App Service
**** 注册小程序
  #+BEGIN_EXAMPLE
       // app.js
       App({
         onLaunch (options) {
           // Do something initial when launch.
         },
         onShow (options) {
           // Do something when show.
         },
         onHide () {
           // Do something when hide.
         },
         onError (msg) {
           console.log(msg)
         },
         globalData: 'I am global data'
       })
   #+END_EXAMPLE
**** 注册页面
***** 使用 Page
   #+BEGIN_EXAMPLE
       //index.js
       Page({
         data: {
           text: "This is page data."
         },
         onLoad: function(options) {
           // 页面创建时执行
         },
         onShow: function() {
           // 页面出现在前台时执行
         },
         onReady: function() {
           // 页面首次渲染完毕时执行
         },
         onHide: function() {
           // 页面从前台变为后台时执行
         },
         onUnload: function() {
           // 页面销毁时执行
         },
         onPullDownRefresh: function() {
           // 触发下拉刷新时执行
         },
         onReachBottom: function() {
           // 页面触底时执行
         },
         onShareAppMessage: function () {
           // 页面被用户分享时执行
         },
         onPageScroll: function() {
           // 页面滚动时执行
         },
         onResize: function() {
           // 页面尺寸变化时执行
         },
         onTabItemTap(item) {
           // tab 点击时执行
           console.log(item.index)
           console.log(item.pagePath)
           console.log(item.text)
         },
         // 事件响应函数
         viewTap: function() {
           this.setData({
             text: 'Set some data for updating view.'
           }, function() {
             // this is setData callback
           })
         },
         // 自由数据
         customData: {
           hi: 'MINA'
         }
       })
   #+END_EXAMPLE
***** 在页面中使用 behaviors
   #+BEGIN_EXAMPLE
       // my-behavior.js
       module.exports = Behavior({
         data: {
           sharedText: 'This is a piece of data shared between pages.'
         },
         methods: {
           sharedMethod: function() {
             this.data.sharedText === 'This is a piece of data shared between pages.'
           }
         }
       })
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
       // page-a.js
       var myBehavior = require('./my-behavior.js')
       Page({
         behaviors: [myBehavior],
         onLoad: function() {
           this.data.sharedText === 'This is a piece of data shared between pages.'
         }
       })
   #+END_EXAMPLE

***** 使用 Component
   #+BEGIN_EXAMPLE
       Component({
         data: {
           text: "This is page data."
         },
         methods: {
           onLoad: function(options) {
             // 页面创建时执行
           },
           onPullDownRefresh: function() {
             // 下拉刷新时执行
           },
           // 事件响应函数
           viewTap: function() {
             // ...
           }
         }
       })
   #+END_EXAMPLE

**** 页面路由
***** 页面栈
      | 路由方式   | 页面栈表现                        |
      |------------+-----------------------------------|
      | 初始化     | 新页面入栈                        |
      | 打开新页面 | 新页面入栈                        |
      | 页面重定向 | 当前页面出栈，新页面入栈          |
      | 页面返回   | 页面不断出栈，直到目标返回页      |
      | Tab 切换   | 页面全部出栈，只留下新的 Tab 页面 |
      | 重加载     | 页面全部出栈，只留下新的页面      |

      开发者可以使用 =getCurrentPages()= 函数获取当前页面栈。

***** 路由方式
      <navigator url="/pages/home/home">home</navigator>
          
      | 打开新页面 | wx.navigateTo        | 组件 <navigator open-type="navigateTo"/>     |
      | 页面重定向 | wx.redirectTo        | 组件 <navigator open-type="redirectTo"/>     |
      | 页面返回   | wx.navigateBack      | 使用组件<navigator open-type="navigateBack"> |
      | Tab 切换   | wx.switchTab         | 使用组件 <navigator open-type="switchTab"/>  |
      | 重启动     | 调用 API wx.reLaunch | 使用组件 <navigator open-type="reLaunch"/>   |

      Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：
  
      | 当前页面          | 路由后页面      | 触发的生命周期（按顺序）                             |
      |-------------------+-----------------+------------------------------------------------------|
      | A                 | A               | Nothing happend                                      |
      | A                 | B               | A.onHide(), B.onLoad(), B.onShow()                   |
      | A                 | B（再次打开）   | A.onHide(), B.onShow()                               |
      | C                 | A               | C.onUnload(), A.onShow()                             |
      | C                 | B               | C.onUnload(), B.onLoad(), B.onShow()                 |
      | D                 | B               | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()   |
      | D（从转发进入）   | A               | D.onUnload(), A.onLoad(), A.onShow()                 |
      | D（从转发进入）   | B               | D.onUnload(), B.onLoad(), B.onShow()                 |

      - =navigateTo=, =redirectTo= 只能打开非 tabBar 页面。
      - =switchTab= 只能打开 tabBar 页面。
      - =reLaunch= 可以打开任意页面。
      - 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有tabBar。
      - 调用页面路由带的参数可以在目标页面的=onLoad=中获取。

**** 模块化
     可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。

     注意：

     -  =exports= 是 module.exports 的一个引用，因此在模块里边随意更改 =exports= 的指向会造成未知的错误。所以更推荐开发者采用 =module.exports= 来暴露模块接口，除非你已经清晰知道这两者的关系。
     -  小程序目前不支持直接引入 =node_modules= , 开发者需要使用到 =node_modules= 时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的npm 功能。

     #+BEGIN_EXAMPLE
         // common.js
         function sayHello(name) {
           console.log(`Hello ${name} !`)
         }
         function sayGoodbye(name) {
           console.log(`Goodbye ${name} !`)
         }

         module.exports.sayHello = sayHello
         exports.sayGoodbye = sayGoodbye
     #+END_EXAMPLE

     在需要使用这些模块的文件中，使用 =require= 将公共代码引入

     #+BEGIN_EXAMPLE
         var common = require('common.js')
         Page({
           helloMINA: function() {
             common.sayHello('MINA')
           },
           goodbyeMINA: function() {
             common.sayGoodbye('MINA')
           }
         })
     #+END_EXAMPLE

**** 文件作用域
     在 JavaScript文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。

     通过全局函数 =getApp= 可以获取全局的应用实例，如果需要全局的数据可以在=App()= 中设置，如：

     #+BEGIN_EXAMPLE
         // app.js
         App({
           globalData: 1
         })
     #+END_EXAMPLE

     #+BEGIN_EXAMPLE
         // a.js
         // The localValue can only be used in file a.js.
         var localValue = 'a'
         // Get the app instance.
         var app = getApp()
         // Get the global data and change it.
         app.globalData++
     #+END_EXAMPLE

     #+BEGIN_EXAMPLE
         // b.js
         // You can redefine localValue in file b.js, without interference with the localValue in a.js.
         var localValue = 'b'
         // If a.js it run before b.js, now the globalData shoule be 2.
         console.log(getApp().globalData)
     #+END_EXAMPLE

**** API
***** 事件监听 API
      我们约定，以 =on= 开头的 API用来监听某个事件是否触发，如：wx.onSocketOpen， wx.onCompassChange等。

      这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。

      #+BEGIN_EXAMPLE
          wx.onCompassChange(function (res) {
            console.log(res.direction)
          })
      #+END_EXAMPLE

***** 同步 API
      我们约定，以 =Sync= 结尾的 API 都是同步 API， 如wx.setStorageSync， wx.getSystemInfoSync等。此外，也有一些其他的同步 API，如wx.createWorker，
      wx.getBackgroundAudioManager等，详情参见 API 文档中的说明。

      同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。

      #+BEGIN_EXAMPLE
          try {
            wx.setStorageSync('key', 'value')
          } catch (e) {
            console.error(e)
          }
      #+END_EXAMPLE

***** 异步 API
      大多数 API 都是异步 API，如wx.request，wx.login等。这类 API 接口通常都接受一个 Object类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：

      *Object 参数说明*
      | 参数名     | 类型       | 必填   | 说明                                               |
      |------------+------------+--------+----------------------------------------------------|
      | success    | function   | 否     | 接口调用成功的回调函数                             |
      | fail       | function   | 否     | 接口调用失败的回调函数                             |
      | complete   | function   | 否     | 接口调用结束的回调函数（调用成功、失败都会执行）   |
      | 其他       | Any        | -      | 接口定义的其他参数                                 |

      *回调函数的参数*

      =success=，=fail=，=complete= 函数调用时会传入一个 =Object=类型参数，包含以下
      字段：

      | 属性    | 类型   | 说明                                                                 |
      |---------+--------+----------------------------------------------------------------------|
      | errMsg  | string | 错误信息，如果调用成功返回 =${apiName}:ok=                           |
      | errCode | number | 错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 =0=。 |
      | 其他    | Any    | 接口返回的其他数据                                                   |

      异步 API 的执行结果需要通过 =Object= 类型的参数中传入的对应回调函数获取。部分异步 API 也会有返回值，可以用来实现更丰富的功能，如 wx.requestwx.connectSocket 等。

      *代码示例*

      #+BEGIN_EXAMPLE
          wx.login({
            success(res) {
              console.log(res.code)
            }
          })
      #+END_EXAMPLE

***** 异步 API 返回 Promise
      1. 部分接口如 =downloadFile=, =request=, =uploadFile=, =connectSocket=, =createCamera=（小游戏）本身就有返回值， 它们的 promisify需要开发者自行封 装。
      2. 当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 =Uncaught (in promise)=，开发者可通过 catch 来进行捕获。
      3. wx.onUnhandledRejection 可以监听未处理的 Promise 拒绝事件。

      *代码示例*
      #+BEGIN_EXAMPLE
          // callback 形式调用
          wx.chooseImage({
            success(res) {
              console.log('res:', res)
            }
          })

          // promise 形式调用
          wx.chooseImage().then(res => console.log('res: ', res))
      #+END_EXAMPLE

*** 视图层 View
**** WXML
***** 数据绑定
      #+BEGIN_EXAMPLE
          <!--wxml-->
          <view> {{message}} </view>
      #+END_EXAMPLE

      #+BEGIN_EXAMPLE
          // page.js
          Page({
            data: {
              message: 'Hello MINA!'
            }
          })
      #+END_EXAMPLE

***** 列表渲染

      #+BEGIN_EXAMPLE
          <!--wxml-->
          <view wx:for="{{array}}"> {{item}} </view>
      #+END_EXAMPLE

      #+BEGIN_EXAMPLE
          // page.js
          Page({
            data: {
              array: [1, 2, 3, 4, 5]
            }
          })
      #+END_EXAMPLE
***** 条件渲染

      #+BEGIN_EXAMPLE
          <!--wxml-->
          <view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
          <view wx:elif="{{view == 'APP'}}"> APP </view>
          <view wx:else="{{view == 'MINA'}}"> MINA </view>
      #+END_EXAMPLE

      #+BEGIN_EXAMPLE
          // page.js
          Page({
            data: {
              view: 'MINA'
            }
          })
      #+END_EXAMPLE

***** 模板
      #+BEGIN_EXAMPLE
          <!--wxml-->
          <template name="staffName">
            <view>
              FirstName: {{firstName}}, LastName: {{lastName}}
            </view>
          </template>

          <template is="staffName" data="{{...staffA}}"></template>
          <template is="staffName" data="{{...staffB}}"></template>
          <template is="staffName" data="{{...staffC}}"></template>
      #+END_EXAMPLE

      #+BEGIN_EXAMPLE
          // page.js
          Page({
            data: {
              staffA: {firstName: 'Hulk', lastName: 'Hu'},
              staffB: {firstName: 'Shang', lastName: 'You'},
              staffC: {firstName: 'Gideon', lastName: 'Lin'}
            }
          })
      #+END_EXAMPLE

**** WXSS
***** 样式导入
      使用 =@import= 语句可以导入外联样式表， =@import= 后跟需要导入的外联样式表的相对路径，用 =;= 表示语句结束。

      #+BEGIN_EXAMPLE
          /** common.wxss **/
          .small-p {
            padding:5px;
          }
      #+END_EXAMPLE

      #+BEGIN_EXAMPLE
          /** app.wxss **/
          @import "common.wxss";
          .middle-p {
            padding:15px;
          }
      #+END_EXAMPLE

***** 内联样式
      #+BEGIN_EXAMPLE
          <view style="color:{{color}};" />
          <view class="normal_view" />
      #+END_EXAMPLE
***** 选择器
      | 选择器           | 样例             | 样例描述                                           |
      |------------------+------------------+----------------------------------------------------|
      | .class           | =.intro=         | 选择所有拥有 class="intro" 的组件                  |
      | #id              | =#firstname=     | 选择拥有 id="firstname" 的组件                     |
      | element          | =view=           | 选择所有 view 组件                                 |
      | element, element | =view, checkbox= | 选择所有文档的 view 组件和所有的 checkbox 组件     |
      | ::after          | =view::after=    | 在 view 组件后边插入内容                   content |
      | ::before         | =view::before=   | 在 view 组件前边插入内容                           |

**** WXS
     WXS（WeiXin Script）是小程序的一套脚本语言，结合=WXML=，可以构建出页面的结构。
***** 页面渲染
      #+BEGIN_EXAMPLE
          <!--wxml-->
          <wxs module="m1">
          var msg = "hello world";

          module.exports.message = msg;
          </wxs>

          <view> {{m1.message}} </view>
      #+END_EXAMPLE

      页面输出：

      #+BEGIN_EXAMPLE
          hello world
      #+END_EXAMPLE

***** 数据处理

      #+BEGIN_EXAMPLE
          // page.js
          Page({
            data: {
              array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
            }
          })
      #+END_EXAMPLE

      #+BEGIN_EXAMPLE
          <!--wxml-->
          <!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 -->
          <wxs module="m1">
          var getMax = function(array) {
            var max = undefined;
            for (var i = 0; i < array.length; ++i) {
              max = max === undefined ?
                array[i] :
                (max >= array[i] ? max : array[i]);
            }
            return max;
          }

          module.exports.getMax = getMax;
          </wxs>

          <!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
          <view> {{m1.getMax(array)}} </view>
      #+END_EXAMPLE

      页面输出：
      5

*** 事件详解
**** 事件分类
     WXML 的冒泡事件列表：

     | 类型               | 触发条件                                                                                  |
     |--------------------+-------------------------------------------------------------------------------------------|
     | touchstart         | 手指触摸动作开始                                                                          |
     | touchmove          | 手指触摸后移动                                                                            |
     | touchcancel        | 手指触摸动作被打断，如来电提醒，弹窗                                                      |
     | touchend           | 手指触摸动作结束                                                                          |
     | tap                | 手指触摸后马上离开                                                                        |
     | longpress          | 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 |
     | longtap            | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）                              |
     | transitionend      | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发                                 |
     | animationstart     | 会在一个 WXSS animation 动画开始时触发                                                    |
     | animationiteration | 会在一个 WXSS animation 一次迭代结束时触发                                                |
     | animationend       | 会在一个 WXSS animation 动画完成时触发                                                    |
     | touchforcechange   | 在支持 3D Touch 的 iPhone 设备，重按时会触发                                              |

**** 绑定并阻止事件冒泡
     除 =bind= 外，也可以用 =catch= 来绑定事件。与 =bind= 不同， =catch=会阻止事件向上冒泡。

     例如在下边这个例子中，点击 inner view会先后调用=handleTap3=和=handleTap2=(因为
     tap 事件会冒泡到 middle view，而middle view 阻止了 tap 事件冒泡，不再向父节点
     传递)，点击 middle view会触发=handleTap2=，点击 outer view 会触发=handleTap1=。

     #+BEGIN_EXAMPLE
         <view id="outer" bindtap="handleTap1">
           outer view
           <view id="middle" catchtap="handleTap2">
             middle view
             <view id="inner" bindtap="handleTap3">
               inner view
             </view>
           </view>
         </view>
     #+END_EXAMPLE


**** 互斥事件绑定
     自基础库版本 [[../../compatibility.html][2.8.2]] 起，除 =bind= 和=catch= 外，还可以使用 =mut-bind= 来绑定事
     件。一个 =mut-bind=触发后，如果事件冒泡到其他节点上，其他节点上的 =mut-bind=绑
     定函数不会被触发，但 =bind= 绑定函数和 =catch= 绑定函数依旧会被触发。

     换而言之，所有 =mut-bind=是“互斥”的，只会有其中一个绑定函数被触发。同时，它
     完全不影响 =bind= 和=catch= 的绑定效果。

     例如在下边这个例子中，点击 inner view 会先后调用 =handleTap3= 和
     =handleTap2= ，点击 middle view 会调用 =handleTap2= 和 =handleTap1= 。

     #+BEGIN_EXAMPLE
         <view id="outer" mut-bind:tap="handleTap1">
           outer view
           <view id="middle" bindtap="handleTap2">
             middle view
             <view id="inner" mut-bind:tap="handleTap3">
               inner view
             </view>
           </view>
         </view>
     #+END_EXAMPLE

**** 事件对象

     如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

     *BaseEvent 基础事件对象属性列表：*

     | 属性          | 类型    | 说明                           |
     |---------------+---------+--------------------------------|
     | [[index_u100.html#type][type]]          | String  | 事件类型                       |
     | [[index_u100.html#timeStamp][timeStamp]]     | Integer | 事件生成时的时间戳             |
     | [[index_u100.html#target][target]]        | Object  | 触发事件的组件的一些属性值集合 |
     | [[index_u100.html#currenttarget][currentTarget]] | Object  | 当前组件的一些属性值集合       |
     | [[index_u100.html#mark][mark]]          | Object  | 事件标记数据                   |
 
     *CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：*

     | 属性                                 | 类型     | 说明         |
     |--------------------------------------+----------+--------------|
     | [[index_u100.html#detail][detail]]   | Object   | 额外的信息   |

     *TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：*
     | 属性                                                 | 类型    | 说明                                           |
     |------------------------------------------------------+---------+------------------------------------------------|
     | [[index_u100.html#touches][touches]]                 | Array   | 触摸事件，当前停留在屏幕中的触摸点信息的数组   |
     | [[index_u100.html#changedTouches][changedTouches]]   | Array   | 触摸事件，当前变化的触摸点信息的数组           |

     *特殊事件： [[../../../component/canvas.html][canvas]]
     中的触摸事件不可冒泡，所以没有 currentTarget。*

*** 简易双向绑定
**** 双向绑定语法
     在 WXML 中，普通的属性的绑定是单向的。例如：

     #+BEGIN_EXAMPLE
         <input value="{{value}}" />
     #+END_EXAMPLE

     如果使用 =this.setData({ value: 'leaf' })= 来更新 =value=，=this.data.value=
     和输入框的中显示的值都会被更新为 =leaf=；但如果用户修改了输入框里的值，却不会
     同时改变 =this.data.value= 。

     如果需要在用户输入的同时改变 =this.data.value=，需要借助简易双向绑定机制。此时，
     可以在对应项目之前加入 =model:= 前缀：

     #+BEGIN_EXAMPLE
         <input model:value="{{value}}" />
     #+END_EXAMPLE

     这样，如果输入框的值被改变了， =this.data.value= 也会同时改变。同时，WXML 中所
     有绑定了 =value= 的位置也会被一同更新，[[../custom-component/observer.html][数据监听器]] 也会被正常触发。

     用于双向绑定的表达式有如下限制：

     1. 只能是一个单一字段的绑定，如

     #+BEGIN_EXAMPLE
         <input model:value="值为 {{value}}" />
         <input model:value="{{ a + b }}" />
     #+END_EXAMPLE

     都是非法的；

     2. 目前，尚不能 data 路径，如
     #+BEGIN_EXAMPLE
         <input model:value="{{ a.b }}" />
     #+END_EXAMPLE

     这样的表达式目前暂不支持。

**** 在自定义组件中传递双向绑定

     双向绑定同样可以使用在自定义组件上。如下的自定义组件：

     #+BEGIN_EXAMPLE
         // custom-component.js
         Component({
           properties: {
             myValue: String
           }
         })
     #+END_EXAMPLE

     #+BEGIN_EXAMPLE
         <!-- custom-component.wxml -->
         <input model:value="{{myValue}}" />
     #+END_EXAMPLE

     这个自定义组件将自身的 =myValue= 属性双向绑定到了组件内输入框的 =value=属性上。
     这样，如果页面这样使用这个组件：

     #+BEGIN_EXAMPLE
         <custom-component model:my-value="{{pageValue}}" />
     #+END_EXAMPLE

     当输入框的值变更时，自定义组件的 =myValue= 属性会同时变更，这样，页面的
     =this.data.pageValue= 也会同时变更，页面 WXML 中所有绑定了 =pageValue=的位置也
     会被一同更新。

**** 在自定义组件中触发双向绑定更新

     自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData设置自身的属性。例
     如：
     #+BEGIN_EXAMPLE
         // custom-component.js
         Component({
           properties: {
             myValue: String
           },
           methods: {
             update: function() {
               // 更新 myValue
               this.setData({
                 myValue: 'leaf'
               })
             }
           }
         })
     #+END_EXAMPLE

     如果页面这样使用这个组件：

     #+BEGIN_EXAMPLE
         <custom-component model:my-value="{{pageValue}}" />
     #+END_EXAMPLE

     当组件使用 =setData= 更新 =myValue= 时，页面的 =this.data.pageValue=也会同时变
     更，页面 WXML 中所有绑定了 =pageValue= 的位置也会被一同更新。

*** 基础组件

    | 属性名         | 类型         | 描述           | 注解                                     |
    |----------------+--------------+----------------+------------------------------------------|
    | id             | String       | 组件的唯一标示 | 保持整个页面唯一                         |
    | class          | String       | 组件的样式类   | 在对应的 WXSS 中定义的样式类             |
    | style          | String       | 组件的内联样式 | 可以动态设置的内联样式                   |
    | hidden         | Boolean      | 组件是否显示   | 所有组件默认显示                         |
    | data-*         | Any          | 自定义属性     | 组件上触发的事件时，会发送给事件处理函数 |
    | bind* / catch* | EventHandler | 组件的事件     | 详见[[file:wxml/event.html][事件]]                                 |

*** 获取界面上的节点信息
**** WXML 节点信息
     [[../../api/wxml/wx.createSelectorQuery.html][节点信息查询 API]]可以用于获取节点属性、样式、在界面上的位置等信息。

     最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

     *示例代码：*

     #+BEGIN_EXAMPLE
         const query = wx.createSelectorQuery()
         query.select('#the-id').boundingClientRect(function(res){
           res.top // #the-id 节点的上边界坐标（相对于显示区域）
         })
         query.selectViewport().scrollOffset(function(res){
           res.scrollTop // 显示区域的竖直滚动位置
         })
         query.exec()
     #+END_EXAMPLE

     上述示例中， =#the-id= 是一个节点选择器，与 CSS的选择器相近但略有区别，请参见
     [[../../api/wxml/SelectorQuery.select.html][SelectorQuery.select]]的相关说明。

     在自定义组件或包含自定义组件的页面中，推荐使用
     =this.createSelectorQuery= 来代替
     [[../../api/wxml/wx.createSelectorQuery.html][wx.createSelectorQuery]]
     ，这样可以确保在正确的范围内选择节点。

**** WXML 节点布局相交状态

     [[../../api/wxml/wx.createIntersectionObserver.html][节点布局相交状态API]]可用于监听两个或多个组件节点在布局位置上的相交状态。这一组
     API 常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。

     这一组 API 涉及的主要概念如下。

     -  参照节点：监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的
       *交集* 作为参照区域。页面显示区域也可作为参照区域之一。
     -  目标节点：监听的目标，默认只能是一个节点（使用 =selectAll=
       选项时，可以同时监听多个节点）。
     -  相交区域：目标节点的布局区域与参照区域的相交区域。
     -  相交比例：相交区域占参照区域的比例。
     -  阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。

     以下示例代码可以在目标节点（用选择器 =.target-class=
     指定）每次进入或离开页面显示区域时，触发回调函数。

     *示例代码：*

     #+BEGIN_EXAMPLE
         Page({
           onLoad: function(){
             wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
               res.id // 目标节点 id
               res.dataset // 目标节点 dataset
               res.intersectionRatio // 相交区域占目标节点的布局区域的比例
               res.intersectionRect // 相交区域
               res.intersectionRect.left // 相交区域的左边界坐标
               res.intersectionRect.top // 相交区域的上边界坐标
               res.intersectionRect.width // 相交区域的宽度
               res.intersectionRect.height // 相交区域的高度
             })
           }
         })
     #+END_EXAMPLE

     以下示例代码可以在目标节点（用选择器 =.target-class=指定）与参照节点（用选择器
     =.relative-class=指定）在页面显示区域内相交或相离，且相交或相离程度达到目标节
     点布局区域的 20%和 50%时，触发回调函数。

     *示例代码：*

     #+BEGIN_EXAMPLE
         Page({
           onLoad: function(){
             wx.createIntersectionObserver(this, {
               thresholds: [0.2, 0.5]
             }).relativeTo('.relative-class').relativeToViewport().observe('.target-class', (res) => {
               res.intersectionRatio // 相交区域占目标节点的布局区域的比例
               res.intersectionRect // 相交区域
               res.intersectionRect.left // 相交区域的左边界坐标
               res.intersectionRect.top // 相交区域的上边界坐标
               res.intersectionRect.width // 相交区域的宽度
               res.intersectionRect.height // 相交区域的高度
             })
           }
         })
     #+END_EXAMPLE

     注意：与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是
     “布局区域”，布局区域可能会在绘制时被其他节点裁剪隐藏（如遇祖先节点中overflow
     样式为 hidden 的节点）或遮盖（如遇 fixed 定位的节点）。

     在自定义组件或包含自定义组件的页面中，推荐使用
     =this.createIntersectionObserver= 来代替[[../../api/wxml/wx.createIntersectionObserver.html][wx.createIntersectionObserver]]，这样可
     以确保在正确的范围内选择节点。

*** 响应显示区域变化
**** 显示区域尺寸
     显示区域指小程序界面中可以自由布局展示的区域。在默认情况下，小程序显示区域的尺
     寸自页面初始化起就不会发生变化。但以下两种方式都可以改变这一默认行为。

***** 在手机上启用屏幕旋转支持

      从小程序基础库版本 [[../compatibility.html][2.4.0]]开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持
      屏幕旋转的方法是：在=app.json= 的 =window= 段中设置 ="pageOrientation":
      "auto"= ，或在页面json 文件中配置 ="pageOrientation": "auto"= 。

      以下是在单个页面 json 文件中启用屏幕旋转的示例。

      *代码示例：*

      #+BEGIN_EXAMPLE
          {
            "pageOrientation": "auto"
          }
      #+END_EXAMPLE


      如果页面添加了上述声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。

      从小程序基础库版本 [[../compatibility.html][2.5.0]] 开始，=pageOrientation= 还可以被设置为 =landscape= ，
      表示固定为横屏显示。

***** [[index_u26.html#在-iPad-上启用屏幕旋转支持][#]] 在 iPad
      上启用屏幕旋转支持


  
 

      从小程序基础库版本 [[../compatibility.html][2.3.0]] 开始，在 iPad
      上运行的小程序可以支持屏幕旋转。使小程序支持 iPad 屏幕旋转的方法是：在
      =app.json= 中添加 ="resizable": true= 。

      *代码示例：*





      #+BEGIN_EXAMPLE
          {
            "resizable": true
          }
      #+END_EXAMPLE





      如果小程序添加了上述声明，则在屏幕旋转时，小程序将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。注意：在
      iPad 上不能单独配置某个页面是否支持屏幕旋转。

**** Media Query
     有时，对于不同尺寸的显示区域，页面的布局会有所差异。此时可以使用 media query
     来解决大多数问题。

     *代码示例：*
     #+BEGIN_EXAMPLE
         .my-class {
           width: 40px;
         }

         @media (min-width: 480px) {
           /* 仅在 480px 或更宽的屏幕上生效的样式规则 */
           .my-class {
             width: 200px;
           }
         }
     #+END_EXAMPLE

     在 WXML 中，可以使用 [[../../component/match-media.html][match-media]]组件来根据 media query 匹配状态展示、隐藏节
     点。

     此外，可以在页面或者自定义组件 JS 中使用=this.createMediaQueryObserver()=
     方法来创建一个[[../../api/wxml/MediaQueryObserver.html][=MediaQueryObserver=]]对象，用于监听指定的 media query 的匹配状
     态。

**** 屏幕旋转事件
     有时，仅仅使用 media query 无法控制一些精细的布局变化。此时可以使用 js作为
     辅助。

     在 js 中读取页面的显示区域尺寸，可以使用[[../../api/wxml/SelectorQuery.selectViewport.html][selectorQuery.selectViewport]]。

     页面尺寸发生改变的事件，可以使用页面的 =onResize=来监听。对于自定义组件，可
     以使用 resize生命周期来监听。回调函数中将返回显示区域的尺寸信息。（从基础库
     版本[[../compatibility.html][2.4.0]] 开始支持。）

     *代码示例：*

     #+BEGIN_EXAMPLE
         Page({
           onResize(res) {
             res.size.windowWidth // 新的显示区域宽度
             res.size.windowHeight // 新的显示区域高度
           }
         })
     #+END_EXAMPLE

     #+BEGIN_EXAMPLE
         Component({
           pageLifetimes: {
             resize(res) {
               res.size.windowWidth // 新的显示区域宽度
               res.size.windowHeight // 新的显示区域高度
             }
           }
         })
     #+END_EXAMPLE


     此外，还可以使用
     [[../../api/ui/window/wx.onWindowResize.html][wx.onWindowResize]]
     来监听（但这不是推荐的方式）。

     *Bug & tips:*

     -  Bug： Android 微信版本 6.7.3 中， =live-pusher=
       组件在屏幕旋转时方向异常。

 
*** 动画
**** 界面动画的常见方式
     在小程序中，通常可以使用 CSS渐变和CSS动画 来创建简易的界面动画。

     动画过程中，可以使用 =bindtransitionend= =bindanimationstart=
     =bindanimationiteration= =bindanimationend= 来监听动画事件。

     | 事件名               | 含义                                                                                                 |
     |----------------------+------------------------------------------------------------------------------------------------------|
     | transitionend        | CSS 渐变结束或 [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]] 结束一个阶段   |
     | animationstart       | CSS 动画开始                                                                                         |
     | animationiteration   | CSS 动画结束一个阶段                                                                                 |
     | animationend         | CSS 动画结束                                                                                         |

     注意：这几个事件都不是冒泡事件，需要绑定在真正发生了动画的节点上才会生效。

**** 关键帧动画

     从小程序基础库 [2.9.0]]开始支持一种更友好的动画创建方式，用于代替旧的 wx.createAnimation。它具有更好的性能和更可控的接口。

     在页面或自定义组件中，当需要进行关键帧动画时，可以使用 =this.animate= 接口：

     #+BEGIN_EXAMPLE
         this.animate(selector, keyframes, duration, callback)
     #+END_EXAMPLE

     *参数说明*

     | 属性      | 类型     | 默认值 | 必填 | 说明                       |
     | keyframes | Array    |        | 是   | 关键帧信息                 |
     | duration  | Number   |        | 是   | 动画持续时长（毫秒为单位） |
     | callback  | function |        | 否   | 动画完成后的回调函数       |

     *keyframes 中对象的结构*

     | 属性            | 类型          | 默认值 | 必填                              | 说明                                    |
     |-----------------+---------------+--------+-----------------------------------+-----------------------------------------|
     | offset          | Number        |        | 否                                | 关键帧的偏移，范围[0-1]                 |
     | ease            | String        | linear | 否                                | 动画缓动函数                            |
     | transformOrigin | String        | 否     | 基点位置，即 CSS transform-origin |                                         |
     | backgroundColor | String        |        | 否                                | 背景颜色，即 CSS background-color       |
     | bottom          | Number/String |        | 否                                | 底边位置，即 CSS bottom                 |
     | height          | Number/String |        | 否                                | 高度，即 CSS height                     |
     | left            | Number/String |        | 否                                | 左边位置，即 CSS left                   |
     | width           | Number/String |        | 否                                | 宽度，即 CSS width                      |
     | opacity         | Number        |        | 否                                | 不透明度，即 CSS opacity                |
     | right           | Number        |        | 否                                | 右边位置，即 CSS right                  |
     | top             | Number/String |        | 否                                | 顶边位置，即 CSS top                    |
     | matrix          | Array         |        | 否                                | 变换矩阵，即 CSS transform matrix       |
     | matrix3d        | Array         |        | 否                                | 三维变换矩阵，即 CSS transform matrix3d |
     | rotate          | Number        |        | 否                                | 旋转，即 CSS transform rotate           |
     | rotate3d        | Array         |        | 否                                | 三维旋转，即 CSS transform rotate3d     |
     | rotateX         | Number        |        | 否                                | X 方向旋转，即 CSS transform rotateX    |
     | rotateY         | Number        |        | 否                                | Y 方向旋转，即 CSS transform rotateY    |
     | rotateZ         | Number        |        | 否                                | Z 方向旋转，即 CSS transform rotateZ    |
     | scale           | Array         |        | 否                                | 缩放，即 CSS transform scale            |
     | scale3d         | Array         |        | 否                                | 三维缩放，即 CSS transform scale3d      |
     | scaleX          | Number        |        | 否                                | X 方向缩放，即 CSS transform scaleX     |
     | scaleY          | Number        |        | 否                                | Y 方向缩放，即 CSS transform scaleY     |
     | scaleZ          | Number        |        | 否                                | Z 方向缩放，即 CSS transform scaleZ     |
     | skew            | Array         |        | 否                                | 倾斜，即 CSS transform skew             |
     | skewX           | Number        |        | 否                                | X 方向倾斜，即 CSS transform skewX      |
     | skewY           | Number        |        | 否                                | Y 方向倾斜，即 CSS transform skewY      |
     | translate       | Array         |        | 否                                | 位移，即 CSS transform translate        |
     | translate3d     | Array         |        | 否                                | 三维位移，即 CSS transform translate3d  |
     | translateX      | Number        |        | 否                                | X 方向位移，即 CSS transform translateX |
     | translateY      | Number        |        | 否                                | Y 方向位移，即 CSS transform translateY |
     | translateZ      | Number        |        | 否                                | Z 方向位移，即 CSS transform translateZ |
**** 滚动驱动的动画

     我们发现，根据滚动位置而不断改变动画的进度是一种比较常见的场景，这类动画可以让人感觉到界面交互很连贯自然，体验更好。因此，从小程序基础库
     [[../compatibility.html][2.9.0]] 开始支持一种由滚动驱动的动画机制。

     基于上述的关键帧动画接口，新增一个 =ScrollTimeline= 的参数，用来绑定滚动元素（目前只支持 scroll-view）。接口定义如下：

     #+BEGIN_EXAMPLE
         this.animate(selector, keyframes, duration, ScrollTimeline)
     #+END_EXAMPLE

     *ScrollTimeline 中对象的结构*
     | 属性                | 类型     | 默认值     | 必填   | 说明                                                                                              |
     |---------------------+----------+------------+--------+---------------------------------------------------------------------------------------------------|
     | scrollSource        | String   |            | 是     | 指定滚动元素的选择器（只支持 scroll-view），该元素滚动时会驱动动画的进度                          |
     | orientation         | String   | vertical   | 否     | 指定滚动的方向。有效值为 horizontal 或 vertical                                                   |
     | startScrollOffset   | Number   |            | 是     | 指定开始驱动动画进度的滚动偏移量，单位 px                                                         |
     | endScrollOffset     | Number   |            | 是     | 指定停止驱动动画进度的滚动偏移量，单位 px                                                         |
     | timeRange           | Number   |            | 是     | 起始和结束的滚动范围映射的时间长度，该时间可用于与关键帧动画里的时间 (duration) 相匹配，单位 ms   |

**** 示例代码

     #+BEGIN_EXAMPLE
           this.animate('.avatar', [{
             borderRadius: '0',
             borderColor: 'red',
             transform: 'scale(1) translateY(-20px)',
             offset: 0,
           }, {
             borderRadius: '25%',
             borderColor: 'blue',
             transform: 'scale(.65) translateY(-20px)',
             offset: .5,
           }, {
             borderRadius: '50%',
             borderColor: 'blue',
             transform: `scale(.3) translateY(-20px)`,
             offset: 1
           }], 2000, {
             scrollSource: '#scroller',
             timeRange: 2000,
             startScrollOffset: 0,
             endScrollOffset: 85,
           })

           this.animate('.search_input', [{
             opacity: '0',
             width: '0%',
           }, {
             opacity: '1',
             width: '100%',
           }], 1000, {
             scrollSource: '#scroller',
             timeRange: 1000,
             startScrollOffset: 120,
             endScrollOffset: 252
           })
     #+END_EXAMPLE

*** 初始渲染缓存
**** 初始渲染缓存工作原理

     小程序页面的初始化分为两个部分。

     -  逻辑层初始化：载入必需的小程序代码、初始化页面 this对象（也包括它涉及到的所
       有自定义组件的 this对象）、将相关数据发送给视图层。
     -  视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发
       送的数据，最后渲染页面。

     在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。

     启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始
     data
     的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：

     -  在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）；
     -  在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来；
     -  如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。

     利用初始渲染缓存，可以：

     -  快速展示出页面中永远不会变的部分，如导航栏；
     -  预先展示一个骨架页，提升用户体验；
     -  展示自定义的加载提示；
     -  提前展示广告，等等。

**** 支持的组件
     在初始渲染缓存阶段中，复杂组件不能被展示或不能响应交互。

     目前支持的内置组件：

     -  =<view />=
     -  =<text />=
     -  =<button />=
     -  =<image />=
     -  =<scroll-view />=
     -  =<rich-text />=

     自定义组件本身可以被展示（但它们里面用到的内置组件也遵循上述限制）。

**** 静态初始渲染缓存
     若想启用初始渲染缓存，最简单的方法是在页面的 =json= 文件中添加配置项 ="initialRenderingCache": "static"= ：
     #+BEGIN_EXAMPLE
         {
           "initialRenderingCache": "static"
         }
     #+END_EXAMPLE
     
     如果想要对所有页面启用，可以在 =app.json= 的 =window= 配置段中添加这个配置：
     
     #+BEGIN_EXAMPLE
         {
           "window": {
             "initialRenderingCache": "static"
           }
         }
     #+END_EXAMPLE

     添加这个配置项之后，在手机中预览小程序首页，然后杀死小程序再次进入，就会通过初始渲染缓存来渲染首页。

     注意：这种情况下，初始渲染缓存记录的是页面 data 应用在页面 WXML
     上的结果，不包含任何 setData 的结果。

     例如，如果想要在页面中展示出“正在加载”几个字，这几个字受到 =loading=
     数据字段控制：





     #+BEGIN_EXAMPLE
         <view wx:if="{{loading}}">正在加载</view>
     #+END_EXAMPLE





     这种情况下， =loading= 应当在 =data= 中指定为 =true= ，如：





     #+BEGIN_EXAMPLE
         // 正确的做法
         Page({
           data: {
             loading: true
           }
         })
     #+END_EXAMPLE





     而不能通过 =setData= 将 =loading= 置为 =true= ：





     #+BEGIN_EXAMPLE
         // 错误的做法！不要这么做！
         Page({
           data: {},
           onLoad: function() {
             this.setData({
               loading: true
             })
           }
         })
     #+END_EXAMPLE





     换而言之，这种做法只包含页面 =data= 的渲染结果，即页面的纯静态成分。

**** [[index_u95.html#在初始渲染缓存中添加动态内容][#]] 在初始渲染缓存中添加动态内容
     有些场景中，只是页面 =data=
     的渲染结果会比较局限。有时会想要额外展示一些可变的内容，如展示的广告图片
     URL 等。

     这种情况下可以使用“动态”初始渲染缓存的方式。首先，配置
     ="initialRenderingCache": "dynamic"= ：





     #+BEGIN_EXAMPLE
         {
           "initialRenderingCache": "dynamic"
         }
     #+END_EXAMPLE





     此时，初始渲染缓存不会被自动启用，还需要在页面中调用
     =this.setInitialRenderingCache(dynamicData)= 才能启用。其中，
     =dynamicData= 是一组数据，与 =data= 一起参与页面 WXML 渲染。





     #+BEGIN_EXAMPLE
         Page({
           data: {
             loading: true
           },
           onReady: function() {
             this.setInitialRenderingCache({
               loadingHint: '正在加载' // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
             })
           }
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         <view wx:if="{{loading}}">{{loadingHint}}</view>
     #+END_EXAMPLE





     从原理上说，在动态生成初始渲染缓存的方式下，页面会在后台使用动态数据重新渲染一次，因而开销相对较大。因而要尽量避免频繁调用
     =this.setInitialRenderingCache=
     ，如果在一个页面内多次调用，仅最后一次调用生效。

     注意：

     -  =this.setInitialRenderingCache= 调用时机不能早于 =Page= 的 =onReady=
       或 =Component= 的 =ready= 生命周期，否则可能对性能有负面影响。
     -  如果想禁用初始渲染缓存，调用 =this.setInitialRenderingCache(null)= 。













     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html]]

     \\
     \\




 













     --------------

** 实现页面跳转
   和通常的 web 开发一样，小程序页面跳转页分 2 中，wxml 中的 vavigator 标签，以
   及 js 的 navigator 相关的 api。

   #+BEGIN_EXAMPLE
       wx.navigateTo，重定向 wx.redirectTo等等，具体的请看官方文档。这里强调一下路由传参，很简单： 
       1、少量数据。直接问号传参。然后在目标页面的onLoad方法中通过options参数接收。 
       2、大量数据。直接塞到全局变量里面。
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
        //  wxml跳转页面
             {{item.name}}

        // js跳转页面
        wx.navigateTo({
             url: `/pages/my/appointDetail/index?_id=${ this .data.marker.id}`
           }) 

       //路由传参如何接收 
   onLoad: function (options) {
   　　 console.log(options)
   },

   #+END_EXAMPLE

** wx.request 的封装
   在 utils 中新建 request.js，简单封装了一下，一些数据要全局配置的都引进来，然后做了些错误的统一处理，没什么难度， 不过要特别注意一下 cookie 的携带。具体代码如
   下：

   #+BEGIN_EXAMPLE
       const app =  getApp()
       export  default  function request(url, options =  {}) {
          return  new Promise( function  (resolve, reject) {
           wx.request({
             url: `${app.origin}${url}`,
             method: 'GET' ,
             ...options,
             data: options.data,
             header: {
               'content-type': 'application/json' ,
               'cookie': wx.getStorageSync("cookie" )
             },
             success:  function  (res) {
                // 重新授权登录
                if (res.statusCode === 401 ){ 
                 wx.redirectTo({url: '/pages/login/index' })
                  return 
               } else  if (res.statusCode !== 200 ) { 
                 reject({ error: '服务器忙，请稍后重试', code: 500  });
                  return 
               }  else  {
                  if (url === '/api/cdz/user/weixin/login' ) {
                   const cookie = res.header["set-cookie" ] || res.header["Set-Cookie"]; 
       　　　　　　　　
                    if (cookie) wx.setStorageSync("cookie" , cookie);
                 }
                 resolve(res.data);
               }
             },
             fail:  function  (res) {
                //  fail调用接口失败
                if (url === '/api/cdz/user/weixin/login' ) {
                 const cookie = res.header["set-cookie" ] || res.header["Set-Cookie"];
                  if (cookie) wx.setStorageSync("cookie" , cookie);
               } 
               reject({ error: '网络错误', code: 0  });
             }
           })
         })
       }
   #+END_EXAMPLE

   然后我们使用的时候直接使用封装好的 request 方法，这样所有的 api 就封装成一个个函数。我们在页面中直接 import 引入调用即可。

   #+BEGIN_EXAMPLE
       import request from "../utils/request" ;
       import { stringify } from "../utils/util" 

       export  function  testPost(data) {
          return request(`/api/test/post`, {
           method: 'PUT' ,
           data,
         })
       }

       export  function  testGet(data) {
          return request(`/api/test/get`)
       }
   #+END_EXAMPLE

* 组件和 api
** 组件
*** view 
    - [view](https://mp.weixin.qq.com/debug/wxadoc/dev/component/view.html)
    - [scroll-view](https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html)
    - [swiper](https://mp.weixin.qq.com/debug/wxadoc/dev/component/swiper.html)

    - [icon](https://mp.weixin.qq.com/debug/wxadoc/dev/component/icon.html)
    - [text](https://mp.weixin.qq.com/debug/wxadoc/dev/component/text.html)
    - [progress](https://mp.weixin.qq.com/debug/wxadoc/dev/component/progress.html)

*** 表单组件
    - [button](https://mp.weixin.qq.com/debug/wxadoc/dev/component/button.html)
    - [checkbox](https://mp.weixin.qq.com/debug/wxadoc/dev/component/checkbox.html)
    - [form](https://mp.weixin.qq.com/debug/wxadoc/dev/component/form.html)
    - [input](https://mp.weixin.qq.com/debug/wxadoc/dev/component/input.html)
    - [label](https://mp.weixin.qq.com/debug/wxadoc/dev/component/label.html)
    - [picker](https://mp.weixin.qq.com/debug/wxadoc/dev/component/picker.html)
    - [radio](https://mp.weixin.qq.com/debug/wxadoc/dev/component/radio.html)
    - [slider](https://mp.weixin.qq.com/debug/wxadoc/dev/component/slider.html)
    - [switch](https://mp.weixin.qq.com/debug/wxadoc/dev/component/switch.html)
    - [textarea](https://mp.weixin.qq.com/debug/wxadoc/dev/component/textarea.html)

*** 导航
    - [navigator](https://mp.weixin.qq.com/debug/wxadoc/dev/component/navigator.html)

*** 媒体组件
    - [audio](https://mp.weixin.qq.com/debug/wxadoc/dev/component/audio.html)
    - [image](https://mp.weixin.qq.com/debug/wxadoc/dev/component/image.html)
    - [video](https://mp.weixin.qq.com/debug/wxadoc/dev/component/video.html)

*** 地图
    - [map](https://mp.weixin.qq.com/debug/wxadoc/dev/component/map.html%20#map)

*** 画布
    - [canvas](https://mp.weixin.qq.com/debug/wxadoc/dev/component/canvas.html)

*** 客服会话
    - [contact-button](https://mp.weixin.qq.com/debug/wxadoc/dev/component/contact-button.html)

** api(https://mp.weixin.qq.com/debug/wxadoc/dev/api/)
*** [网络](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-network.html)
**** [发起请求](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html)
     - `wx.request`   `wx.request` 发起的是 HTTPS 请求
**** [上传、下载](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-file.html)
     - `wx.uploadFile`   将本地资源上传到开发者服务器
     - `wx.downloadFile` 下载文件资源到本地
**** [WebSocket](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)
     - `wx.connectSocket`  创建一个 WebSocket 连接
     - `wx.onSocketOpen`   监听 WebSocket 连接打开事件
     - `wx.onSocketError`  监听 WebSocket 错误
     - `wx.sendSocketMessage`  通过 WebSocket 连接发送数据
     - `wx.onSocketMessage`  监听 WebSocket 接受到服务器的消息事件
     - `wx.closeSocket`    关闭 WebSocket 连接
     - `wx.onSocketClose`  监听 WebSocket 关闭
*** [媒体](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-picture.html)
**** [图片](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-picture.html)

     - `wx.chooseImage`  从本地相册选择图片或使用相机拍照
     - `wx.previewImage` 预览图片
     - `wx.getImageInfo` 获取图片信息
**** [录音](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-record.html)

     - `wx.startRecord`  开始录音
     - `wx.stopRecord`   主动调用停止录音
**** [音频播放控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-voice.html)

     - `wx.playVoice`    开始播放语音
     - `wx.pauseVoice`   暂停正在播放的语音
     - `wx.stopVoice`    结束播放语音
**** [音乐播放控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-background-audio.html)

     - `wx.getBackgroundAudioPlayerState`  获取音乐播放状态
     - `wx.playBackgroundAudio`  播放音乐，同时只能有一首音乐正在播放
     - `wx.pauseBackgroundAudio` 暂停播放音乐
     - `wx.seekBackgroundAudio`  控制音乐播放进度
     - `wx.stopBackgroundAudio`  停止播放音乐
     - `wx.onBackgroundAudioPlay`  监听音乐播放
     - `wx.onBackgroundAudioPause` 监听音乐暂停
     - `wx.onBackgroundAudioStop`  监听音乐停止
**** [音频组件控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

     - `wx.createAudioContext` 创建并返回 audio 上下文 `audioContext` 对象
**** [视频](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

     - `wx.chooseVideo`  拍摄视频或从手机相册中选视频，返回视频的临时文件路径
**** [视频组件控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

     - `wx.createVideoContext`  创建并返回 video 上下文 `videoContext` 对象
*** [文件](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)
    - `wx.saveFile` 保存文件到本地
    - `wx.getSavedFileList` 获取本地已保存的文件列表
    - `wx.getSavedFileInfo` 获取本地文件的文件信息
    - `wx.removeSavedFile` 删除本地存储的文件
    - `wx.openDocument` 新开页面打开文档，支持格式：doc, xls, ppt, pdf, docx, xlsx, pptx
*** [数据缓存](https://mp.weixin.qq.com/debug/wxadoc/dev/api/data.html)

    - `wx.setStorage`   将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口
    - `wx.setStorageSync` 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口
    - `wx.getStorage`  从本地缓存中异步获取指定 key 对应的内容
    - `wx.getStorageSync` 从本地缓存中同步获取指定 key 对应的内容
    - `wx.getStorageInfo` 异步获取当前 storage 的相关信息
    - `wx.getStorageInfoSync` 同步获取当前 storage 的相关信息
    - `wx.removeStorage`  从本地缓存中异步移除指定 key
    - `wx.removeStorageSync`  从本地缓存中同步移除指定 key
    - `wx.clearStorage` 清理本地数据缓存
    - `wx.clearStorageSync` 同步清理本地数据缓存
*** [位置](https://mp.weixin.qq.com/debug/wxadoc/dev/api/location.html)
**** 获取位置
     - `wx.getLocation` 获取当前的地理位置、速度
     - `wx.chooseLocation` 打开地图选择位置
**** 查看位置
     - `wx.openLocation` 使用微信内置地图查看位置
**** [地图组件控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-map.html)

     - `wx.createMapContext` 创建并返回 map 上下文 mapContext 对象
*** [设备](https://mp.weixin.qq.com/debug/wxadoc/dev/api/device.html)
**** [系统信息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/systeminfo.html)

     - `wx.getSystemInfo` 获取系统信息
     - `wx.getSystemInfoSync` 获取系统信息同步接口
**** [网络状态](https://mp.weixin.qq.com/debug/wxadoc/dev/api/device.html)

     - `wx.getNetworkType` 获取网络类型
**** [重力感应](https://mp.weixin.qq.com/debug/wxadoc/dev/api/accelerometer.html)

     - `wx.onAccelerometerChange`  监听重力感应数据，频率：5次/秒
**** [罗盘](https://mp.weixin.qq.com/debug/wxadoc/dev/api/campass.html)

     - `wx.onCompassChange`  监听罗盘数据，频率：5次/秒
**** [拨打电话](https://mp.weixin.qq.com/debug/wxadoc/dev/api/phonecall.html)

     - `wx.makePhoneCall`  拨打电话
**** [扫码](https://mp.weixin.qq.com/debug/wxadoc/dev/api/scancode.html)

     - `wx.scanCode` 调起客户端扫码界面，扫码成功后返回对应的结果
*** [界面](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-react.html)
**** [交互反馈](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-react.html)

     - `wx.showToast` 显示消息提示框
     - `wx.hideToast` 隐藏消息提示框
     - `wx.showModal` ​显示模态弹窗
     - `wx.showActionSheet` 显示操作菜单
**** [设置导航条](https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui.html)

     - `wx.setNavigationBarTitle` 动态设置当前页面的标题
     - `wx.showNavigationBarLoading` 在当前页面显示导航条加载动画
     - `wx.hideNavigationBarLoading` 隐藏导航条加载动画
**** [导航](https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html)

     - `wx.navigateTo`  保留当前页面，跳转到应用内的某个页面，使用 `wx.navigateBack` 可以返回到原页面
     - `wx.redirectTo` 关闭当前页面，跳转到应用内的某个页面
     - `wx.switchTab`  跳转到 `tabBar` 页面，并关闭其他所有非 `tabBar` 页面
     - `wx.navigateBack`  关闭当前页面，返回上一页面或多级页面。可通过 `getCurrentPages()` 获取当前的页面栈，决定需要返回几层
**** [动画](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-animation.html)

     - `wx.createAnimation`  创建一个动画实例 `animation`。调用实例的方法来描述动画。最后通过动画实例的`export` 方法导出动画数据传递给组件的 `animation` 属性。
     - animation
     - 动画队列
**** [绘图](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/intro.html)

     - [简介 intro](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/intro.html)
     - [Canvas 坐标系](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/coordinates.html)
     - [渐变](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/gradient.html)
     - [API 接口索引](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/reference.html)
     - [wx.createCanvasContext](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/create-canvas-context.html) 创建 canvas 绘图上下文（指定 canvasId）
     - [wx.canvasToTempFilePath](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/reference.html) 把当前画布的内容导出生成图片，并返回文件路径
**** [下拉刷新](https://mp.weixin.qq.com/debug/wxadoc/dev/api/pulldown.html)

     - `Page.onPullDownRefresh` 在 `Page` 中定义 `onPullDownRefresh` 处理函数，监听该页面用户下拉刷新事件
     - `wx.stopPullDownRefresh` 停止当前页面下拉刷新
*** [开放接口](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html)
**** [登录](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html)
     - `wx.login` 调用接口获取登录凭证（code）进而换取用户登录态信息
     - `code` 换取 `session_key`
     - 登录态维护
       - 登录时序图
       - `wx.checkSession` 检查登陆态是否过期
     - [用户数据的签名验证和加解密](https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html)
       - 数据签名校验
       - 加密数据解密算法
**** [用户信息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/open.html)
     - `wx.getUserInfo` 获取用户信息，需要先调用 `wx.login` 接口说明
     - `UnionID` 机制说明
**** [微信支付](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html)

     - `wx.requestPayment` 发起微信支付
**** [模板消息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/notice.html)

     - 使用说明
     - 接口说明
       - 获取 access_token
       - 发送模板消息
       - 下发条件说明
       - 审核说明
       - 违规说明
       - 处罚说明
**** 客服消息
     - [接收消息和事件](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/receive.html)
       - 文本消息
       - 图片消息
       - 进入会话事件
     - [发送客服消息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/conversation.html)
     - [临时素材接口](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/material.html)
       - 获取临时素材
       - 新增临时素材
     - [接入指引](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/callback_help.html)
**** [分享](https://mp.weixin.qq.com/debug/wxadoc/dev/api/share.html)

     - Page.onShareAppMessage
*** 基础
**** wx.canIUse 
     判断小程序的API，回调，参数，组件等是否在当前版本可用。

     参数
     string schema
     使用 ${API}.${method}.${param}.${option} 或者 ${component}.${attribute}.${option} 方式来调用
***** 参数说明
      ${API} 代表 API 名字
      ${method} 代表调用方式，有效值为return, success, object, callback
      ${param} 代表参数或者返回值
      ${option} 代表参数的可选值或者返回值的属性
      ${component} 代表组件名字
      ${attribute} 代表组件属性
      ${option} 代表组件属性的可选值
***** 示例代码
      // 对象的属性或方法
      wx.canIUse('console.log')
      wx.canIUse('CameraContext.onCameraFrame')
      wx.canIUse('CameraFrameListener.start')
      wx.canIUse('Image.src')

      // wx接口参数、回调或者返回值
      wx.canIUse('openBluetoothAdapter')
      wx.canIUse('getSystemInfoSync.return.safeArea.left')
      wx.canIUse('getSystemInfo.success.screenWidth')
      wx.canIUse('showToast.object.image')
      wx.canIUse('onCompassChange.callback.direction')
      wx.canIUse('request.object.method.GET')

      // 组件的属性
      wx.canIUse('live-player')
      wx.canIUse('text.selectable')
      wx.canIUse('button.open-type.contact')

*** 开放接口
**** 登录
     wx.login
     wx.checkSession
**** 小程序跳转
     wx.navigateToMiniProgram
     wx.navigateBackMiniProgram
**** 帐号信息
     wx.getAccountInfoSync
**** 用户信息
     wx.getUserInfo
     UserInfo
**** 数据上报
     wx.reportMonitor
**** 数据分析
     wx.reportAnalytics
**** 支付
     wx.requestPayment
**** 授权
     wx.authorize
**** 设置
     wx.openSetting
     wx.getSetting
     AuthSetting
     SubscriptionsSetting
**** 收货地址
     wx.chooseAddress
**** 卡券
     wx.openCard
     wx.addCard
**** 发票
     wx.chooseInvoiceTitle
     wx.chooseInvoice
**** 生物认证
     wx.startSoterAuthentication
     wx.checkIsSupportSoterAuthentication
     wx.checkIsSoterEnrolledInDevice
**** 微信运动
     wx.getWeRunData
**** 性能
     wx.reportPerformance
     wx.getPerformance
***** EntryList
      EntryList.getEntries
      EntryList.getEntriesByName
      EntryList.getEntriesByType
***** Performance
      Performance.createObserver
      Performance.getEntries
      Performance.getEntriesByName
      Performance.getEntriesByType
      Performance.setBufferSize
***** PerformanceObserver
      PerformanceObserver.disconnect
      PerformanceObserver.observe
**** 订阅消息
     wx.requestSubscribeMessage
**** 微信红包
     wx.showRedPackage
**** 群工具
     wx.getGroupEnterInfo

* 事件
** 事件类型 
   -  tap：触摸后马上离开。
   -  longpress：触摸后，超过 350ms 再离开。如果指定了该事件的回调函数并触发了该事件，tap事件将不被触发。
   -  touchstart：触摸开始。
   -  touchmove：触摸后移动。
   -  touchcancel：触摸动作被打断，如来电提醒，弹窗等。
   -  touchend：触摸结束。
** 事件属性
   - capture-bind：捕获阶段触发。
   - capture-catch：捕获阶段触发，并中断事件，不再向下传播，即中断捕获阶段，并取消随后的冒泡阶段。
   - bind：冒泡阶段触发。
   - catch：冒泡阶段触发，并取消事件进一步向上冒泡。

* WXML语法  
** 数据绑定 
*** 控制属性
    <view wx:if="{{condition}}"> </view>
*** 三元运算
    <view hidden="{{flag ? true : false}}"> Hidden </view>
*** 算数运算
    <view> {{a + b}} + {{c}} + d </view>
*** 逻辑判断
    <view wx:if="{{length > 5}}"> </view>
*** 字符串运算
    <view>{{"hello" + name}}</view>
*** 数组
    <view wx:for="{{[zero, 1, 2, 3, 4]}}"> {{item}} </view>
*** 对象
    <template is="objectCombine" data="{{for: a, bar: b}}"></template>
*** 也可以用扩展运算符 ... 来将一个对象展开
    <template is="objectCombine" data="{{...obj1, ...obj2, e: 5}}"></template>
** 列表渲染
*** wx:for
    在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。

    默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item

    <view wx:for="{{array}}">
    {{index}}: {{item.message}}
    </view>
    Page({
    data: {
    array: [{
    message: 'foo',
    }, {
    message: 'bar'
    }]
    }
    })
    使用 wx:for-item 可以指定数组当前元素的变量名，

    使用 wx:for-index 可以指定数组当前下标的变量名：

    <view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
    {{idx}}: {{itemName.message}}
    </view>
    wx:for 也可以嵌套，下边是一个九九乘法表

    <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
    <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    <view wx:if="{{i <= j}}">
    {{i}} * {{j}} = {{i * j}}
    </view>
    </view>
    </view>
    block wx:for
    类似 block wx:if，也可以将 wx:for 用在<block/>标签上，以渲染一个包含多节点的结构块。例如：

    <block wx:for="{{[1, 2, 3]}}">
    <view> {{index}}: </view>
    <view> {{item}} </view>
    </block>
*** wx:key
    如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目
    保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用
    wx:key 来指定列表中项目的唯一的标识符。

    wx:key 的值以两种形式提供

    字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
    保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。
 
    当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新
    排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

    如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。

    示例代码：

    <switch wx:for="{{objectArray}}" wx:key="unique" style="display: block;"> {{item.id}} </switch>
    <button bindtap="switch"> Switch </button>
    <button bindtap="addToFront"> Add to the front </button>

    <switch wx:for="{{numberArray}}" wx:key="*this" style="display: block;"> {{item}} </switch>
    <button bindtap="addNumberToFront"> Add to the front </button>
    Page({
    data: {
    objectArray: [
    {id: 5, unique: 'unique_5'},
    {id: 4, unique: 'unique_4'},
    {id: 3, unique: 'unique_3'},
    {id: 2, unique: 'unique_2'},
    {id: 1, unique: 'unique_1'},
    {id: 0, unique: 'unique_0'},
    ],
    numberArray: [1, 2, 3, 4]
    },
    switch: function(e) {
    const length = this.data.objectArray.length
    for (let i = 0; i < length; ++i) {
    const x = Math.floor(Math.random() * length)
    const y = Math.floor(Math.random() * length)
    const temp = this.data.objectArray[x]
    this.data.objectArray[x] = this.data.objectArray[y]
    this.data.objectArray[y] = temp
    }
    this.setData({
    objectArray: this.data.objectArray
    })
    },
    addToFront: function(e) {
    const length = this.data.objectArray.length
    this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)
    this.setData({
    objectArray: this.data.objectArray
    })
    },
    addNumberToFront: function(e){
    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    this.setData({
    numberArray: this.data.numberArray
    })
    }
    })
    注意：

    当 wx:for 的值为字符串时，会将字符串解析成字符串数组

    <view wx:for="array">
    {{item}}
    </view>
    等同于

    <view wx:for="{{['a','r','r','a','y']}}">
    {{item}}
    </view>
    注意： 花括号和引号之间如果有空格，将最终被解析成为字符串

    <view wx:for="{{[1,2,3]}} ">
    {{item}}
    </view>
    等同于

    <view wx:for="{{[1,2,3] + ' '}}" >
    {{item}}
    </view>
