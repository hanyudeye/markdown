<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Spring.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

<h2 id="java-编译">java 编译</h2>
<p><img src="../image/java/2021-05-01_10-00.png" /></p>
<p>直接在文件目录执行编译，就不会报错</p>
<pre><code>javac *.java</code></pre>
<h2 id="java执行">java执行</h2>
<p><img src="../image/java/2021-05-01_10-03.png" /></p>
<p>进入包最外层的目录,执行指定的类，类中必须要有 <strong>main</strong> 函数</p>
<pre><code>java 包名.类名  </code></pre>
<h2 id="spring-依赖">Spring 依赖</h2>
<p>在maven仓库中，搜索 Spring 关键词，选择 spring-context 依赖，拷贝到 pom.xml 文件的dependency 节点下面即可</p>
<p><img src="image/java/2021-05-01_20-59.png" /></p>
<h2 id="spring-核心-api">Spring 核心 API</h2>
<ul>
<li>ApplicationContext</li>
</ul>
<pre><code>1. 作用: Spring 提供的ApplicationContext 这个工厂，用于对象的创建
2. 好处: 解耦合</code></pre>
<pre><code>- ApplicationContext 接口类型</code></pre>
<pre><code>接口  : 屏蔽实现的差异
非Web环境 : ClassPathXmlApplicationContext
web环境 ： XmlWebApplicationContext</code></pre>
<blockquote>
<p>这两个实现对象占用大量内存，所以不会频繁创建，一个应用只会创建一个工厂对象。<br />
它们是线程安全的(做了锁的设置)</p>
</blockquote>
<h2 id="程序开发">程序开发</h2>
<pre><code>1.创建类型
2.配置文件的配置 applicationContext.xml
3.通过工厂类，获得对象
ApplicationContext 

ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;/applicationContext.xml);
Person person=(Person)ctx.getBean(&quot;Person&quot;);
</code></pre>
<h2 id="配置文件中需要注意的细节">配置文件中需要注意的细节</h2>
<h2 id="spring-与日志框架的整合">Spring 与日志框架的整合</h2>
<blockquote>
<p>好处：便于了解Spring 框架的运行过程，便于程序的调试</p>
</blockquote>
<ul>
<li>如何整合</li>
</ul>
<ol type="1">
<li>Spring1.2.3 早期的版本都是与 commons-logging.jar 整合</li>
<li>Spring5.x 默认整合的日志框架是 logback log4j2 (整合好了)</li>
</ol>
<ul>
<li>实际 整合 log4j (log4j 与 log4j2 差别很大)</li>
</ul>
<ol type="1">
<li>引入 log4j jar包</li>
<li>引入 log4.properties 配置文件</li>
</ol>
<ul>
<li>pom</li>
</ul>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
  &lt;version&gt;1.7.21&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;log4j&lt;/groupId&gt;
  &lt;artifactId&gt;log4j&lt;/artifactId&gt;
  &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>引⼊ log4j.properties 配置⽂件；</li>
</ul>
<pre><code># resources文件夹根目录下
### 配置根

log4j.rootLogger = debug,console
### 日志输出到控制台显示
log4j.appender.console=org.apache.log4j.ConsoleAppender
log4j.appender.console.Target=System.out
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n</code></pre>
<h2 id="注入">注入</h2>
<ol type="1">
<li>什么是注入 &gt; 通过Spring 工厂及配置文件，为所创建对象的成员变量赋值</li>
</ol>
<p>1.1 为什么需要注入 通过编码的方式，为成员变量进行赋值，存在耦合 <img src="./image/java/2021-05-03_21-44.png" /></p>
<p>1.2 如何进行注入 [开发步骤]</p>
<pre><code>类的成员变量提供 set get 方法  
配置 spring 的配置文件</code></pre>
<p><img src="image/java/2021-05-04_08-06.png" /> <img src="image/java/2021-05-03_21-56.png" /> 1.3 注入的好处 &gt; 解耦合 (代码的类和实现分离)</p>
<p>1.4 set 注入详解 <img src="image/java/2021-05-04_08-14.png" /></p>
<ul>
<li>JDK 内置类型</li>
</ul>
<p>数组</p>
<pre><code> &lt;property name=&quot;emails&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;abc@qq.com&lt;/value&gt;
        &lt;value&gt;123@qq.com&lt;/value&gt;
        &lt;value&gt;hello@qq.com&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;</code></pre>
<p>Set集合</p>
<pre><code>&lt;property name=&quot;tels&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;138xxxxxxxxxx&lt;/value&gt;
        &lt;value&gt;139xxxxxxxxxx&lt;/value&gt;
        &lt;value&gt;138xxxxxxxxxx&lt;/value&gt;&lt;!--set会自动去重--&gt;
    &lt;/set&gt;
&lt;/property&gt;
</code></pre>
<p>List集合</p>
<pre><code>&lt;property name=&quot;addresses&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;China&lt;/value&gt;
        &lt;value&gt;Earth&lt;/value&gt;
        &lt;value&gt;hell&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;</code></pre>
<p>Map集合</p>
<pre><code>&lt;property name=&quot;qqs&quot;&gt;
    &lt;map&gt;
        &lt;entry&gt;
            &lt;key&gt;&lt;value&gt;hello&lt;/value&gt;&lt;/key&gt;
            &lt;value&gt;12312312312&lt;/value&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;key&gt;&lt;value&gt;world&lt;/value&gt;&lt;/key&gt;
            &lt;value&gt;21314214214&lt;/value&gt;
        &lt;/entry&gt;
    &lt;/map&gt;
&lt;/property&gt;</code></pre>
<p>Properites &gt; 特殊的Map 类型</p>
<pre><code>&lt;property name=&quot;p&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;key1&quot;&gt;value1&lt;/prop&gt;
        &lt;prop key=&quot;key2&quot;&gt;value2&lt;/prop&gt;
        &lt;prop key=&quot;key3&quot;&gt;value3&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;</code></pre>
<ul>
<li>复杂的 JDK 类型 (自定义) &gt; 需要程序员自定义类型转换器，处理</li>
</ul>
<ol type="1">
<li>用户自定义类型 1.1 第一种方式</li>
</ol>
<ul>
<li>为成员变量提供 set get 方法</li>
<li>配置文件中进行注入 (赋值)</li>
</ul>
<p><img src="image/java/2021-05-04_09-19.png" /></p>
<blockquote>
<p>用接口类型，与实现分离 <img src="image/java/2021-05-04_09-21.png" /></p>
</blockquote>
<p>1.2 第二种方式 * 第一种方式存在的问题<br />
配置⽂件代码冗余；<br />
被注入的对象 （UserDAO）多次创建，浪费（JVM)内存资源。</p>
<p>[开发步骤]：</p>
<p>为成员变量提供 set get ⽅法；<br />
配置⽂件中进⾏配置；</p>
<pre><code>&lt;bean id=&quot;userDAO&quot; class=&quot;com.yusael.dao.UserDAOImpl&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;userService&quot; class=&quot;com.yusael.service.UserServiceImpl&quot;&gt;
    &lt;property name=&quot;userDAO&quot;&gt;
        &lt;ref bean=&quot;userDAO&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
<p>Spring4.x 废除了 <ref local=""/> 基本等效 <ref bean=""/>；</p>

</body>
</html>
