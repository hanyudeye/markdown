
* 微信小程序 
** 简介  
   微信，作为小型DOM 解析器，解析类 VUE 代码
   每个微信开发者账号可以有5个小程序

   - 没有DOM
   - 组件化开发
   - 适配方案 rpx(responsive pixel 响应式像素单位) 750rpx [全是手机屏幕,电脑上也是]

** 开发流程  
   1. 有一个邮箱
   2. 用邮箱注册小程序账号，并且获取微信小程序AppID
   3. 用注册的小程序账号登录微信公众平台
   4. 完善小程序信息并且添加开发者（至少一个）
   5. 在微信web开发者工具上开发小程序
   6. 微信公众号与微信小程序绑定
   7. 发布小程序代码
   8. 提交绑定
** 配置
*** 配置文件 app.json  
    #+begin_src json
      "window": {
          "backgroundTextStyle": "light",
          "navigationBarBackgroundColor": "#fff",
          "navigationBarTitleText": "Weixin",
          "navigationBarTextStyle": "black",
          //允许下拉刷新
          "enablePullDownRefresh": true,
          //允许上拉加载，然后内容够多，能够溢出 "height:100vh"
          "onReachBottomDistance": 50 ,//默认值是50
          // 屏幕旋转 landscape 横屏
          "pageOrientation": "auto"
          //在ipad 上启用屏幕旋转支持 
          "resizable": true
      },
    #+end_src
*** 索引文件 sitemap.json 
   > 配置小程序及其页面是否允许被微信索引
**** 配置 path/to/page 页面被索引，其余页面不被索引
     #+begin_src json
        {
          "rules":[{
            "action": "allow",
            "page": "path/to/page"
          }, {
            "action": "disallow",
            "page": "*"
          }]
        }
    #+end_src

** 框架
*** 逻辑层 js
#+begin_src js
       App({
         onLaunch (options) {
           // Do something initial when launch.
           //启动事件
         },
         onShow (options) {
           // Do something when show.
           // 页面显示事件
         },
         onHide () {
           // Do something when hide.
           //隐藏事件
         },
         onError (msg) {
           console.log(msg)
           // 发生错误事件
         },
         // app 对象包含的数据 
         globalData: 'I am global data'
       })
#+end_src

#+begin_src js
  Page({
      data: {
          text: "This is page data."
      },
      onLoad: function(options) {
          // 页面创建时执行
      },
      onShow: function() {
          // 页面出现在前台时执行
      },
      onReady: function() {
          // 页面首次渲染完毕时执行
      },
      onHide: function() {
          // 页面从前台变为后台时执行
      },
      onUnload: function() {
          // 页面销毁时执行
      },
      onPullDownRefresh: function() {
          // 触发下拉刷新时执行
      },
      onReachBottom: function() {
          // 页面触底时执行
      },
      onShareAppMessage: function () {
          // 页面被用户分享时执行
      },
      onPageScroll: function() {
          // 页面滚动时执行
      },
      onResize: function() {
          // 页面尺寸变化时执行
      },
      onTabItemTap(item) {
          // tab 点击时执行
          console.log(item.index)
          console.log(item.pagePath)
          console.log(item.text)
      },
      // 事件响应函数
      viewTap: function() {
          this.setData({
              text: 'Set some data for updating view.'
          }, function() {
              // this is setData callback
          })
      },
      // 自由数据
      customData: {
          hi: 'MINA'
      }
  })

#+end_src

**** 在页面中使用行为 behaviors
#+begin_src js
  // my-behavior.js
  module.exports = Behavior({
      data: {
          sharedText: 'This is a piece of data shared between pages.'
      },
      methods: {
          sharedMethod: function() {
              this.data.sharedText === 'This is a piece of data shared between pages.'
          }
      }
  })

  #+end_src

#+begin_src js
  // page-a.js
  var myBehavior = require('./my-behavior.js')
  Page({
      behaviors: [myBehavior],
      onLoad: function() {
          this.data.sharedText === 'This is a piece of data shared between pages.'
      }
  })

       #+end_src

**** 使用组件 Component
  #+begin_src js
    Component({
        data: {
            text: "This is page data."
        },
        methods: {
            onLoad: function(options) {
                // 页面创建时执行
            },
            onPullDownRefresh: function() {
                // 下拉刷新时执行
            },
            // 事件响应函数
            viewTap: function() {
                // ...
            }
        }
    })
      #+end_src
      
**** 模块化
     可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。

     注意：
     - =exports= 是 module.exports 的一个引用，因此在模块里边随意更改 =exports= 的指向会造成未知的错误。所以更推荐开发者采用 =module.exports= 来暴露模块接口，除非你已经清晰知道这两者的关系。
     - 小程序目前不支持直接引入 =node_modules= , 开发者需要使用到 =node_modules= 时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的npm 功能。
#+begin_src js
  // common.js
  function sayHello(name) {
      console.log(`Hello ${name} !`)
  }
  function sayGoodbye(name) {
      console.log(`Goodbye ${name} !`)
  }
  
  module.exports.sayHello = sayHello
  exports.sayGoodbye = sayGoodbye
  #+end_src

在需要使用这些模块的文件中，使用 =require= 将公共代码引入

#+begin_src js
         var common = require('common.js')
         Page({
           helloMINA: function() {
             common.sayHello('MINA')
           },
           goodbyeMINA: function() {
             common.sayGoodbye('MINA')
           }
         })
#+end_src
**** 文件作用域
     通过全局函数 =getApp= 可以获取全局的应用实例，如果需要全局的数据可以在
     =App()= 中设置，如：

#+begin_src js
  // app.js
  App({
    globalData: 1
  })
  
  // a.js
  // The localValue can only be used in file a.js.
  var localValue = 'a'
  // Get the app instance.
  var app = getApp()
  // Get the global data and change it.
  app.globalData++
  
  // b.js
  // You can redefine localValue in file b.js, without interference with the localValue in a.js.
  var localValue = 'b'
  // If a.js it run before b.js, now the globalData shoule be 2.
  console.log(getApp().globalData)
  
#+end_src
**** API
***** 事件监听 API
      我们约定，以 =on= 开头的 API用来监听某个事件是否触发，如：wx.onSocketOpen， wx.onCompassChange等。

      这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。

      #+BEGIN_EXAMPLE
          wx.onCompassChange(function (res) {
            console.log(res.direction)
          })
      #+END_EXAMPLE

***** 同步 API
      我们约定，以 =Sync= 结尾的 API 都是同步 API， 如wx.setStorageSync， wx.getSystemInfoSync等。此外，也有一些其他的同步 API，如wx.createWorker，
      wx.getBackgroundAudioManager等，详情参见 API 文档中的说明。

      同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。

      #+BEGIN_EXAMPLE
          try {
            wx.setStorageSync('key', 'value')
          } catch (e) {
            console.error(e)
          }
      #+END_EXAMPLE

***** 异步 API
      大多数 API 都是异步 API，如wx.request，wx.login等。这类 API 接口通常都接受一个 Object类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：

      *Object 参数说明*
      | 参数名     | 类型       | 必填   | 说明                                               |
      |------------+------------+--------+----------------------------------------------------|
      | success    | function   | 否     | 接口调用成功的回调函数                             |
      | fail       | function   | 否     | 接口调用失败的回调函数                             |
      | complete   | function   | 否     | 接口调用结束的回调函数（调用成功、失败都会执行）   |
      | 其他       | Any        | -      | 接口定义的其他参数                                 |

      *回调函数的参数*

      =success=，=fail=，=complete= 函数调用时会传入一个 =Object=类型参数，包含以下
      字段：

      | 属性    | 类型   | 说明                                                                 |
      |---------+--------+----------------------------------------------------------------------|
      | errMsg  | string | 错误信息，如果调用成功返回 =${apiName}:ok=                           |
      | errCode | number | 错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 =0=。 |
      | 其他    | Any    | 接口返回的其他数据                                                   |

      异步 API 的执行结果需要通过 =Object= 类型的参数中传入的对应回调函数获取。部分异步 API 也会有返回值，可以用来实现更丰富的功能，如 wx.requestwx.connectSocket 等。

      *代码示例*

      #+BEGIN_EXAMPLE
          wx.login({
            success(res) {
              console.log(res.code)
            }
          })
      #+END_EXAMPLE

***** 异步 API 返回 Promise
      1. 部分接口如 =downloadFile=, =request=, =uploadFile=, =connectSocket=, =createCamera=（小游戏）本身就有返回值， 它们的 promisify需要开发者自行封 装。
      2. 当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 =Uncaught (in promise)=，开发者可通过 catch 来进行捕获。
      3. wx.onUnhandledRejection 可以监听未处理的 Promise 拒绝事件。

      *代码示例*
      #+BEGIN_EXAMPLE
          // callback 形式调用
          wx.chooseImage({
            success(res) {
              console.log('res:', res)
            }
          })

          // promise 形式调用
          wx.chooseImage().then(res => console.log('res: ', res))
      #+END_EXAMPLE

*** 视图层 View
**** WXML
***** 数据绑定
      #+begin_src html
        <view> {{message}} </view>
      #+end_src
***** 列表渲染
      #+begin_src html
        <view wx:for="{{array}}"> {{item}} </view>
      #+end_src
***** 条件渲染
      #+begin_src html
        <view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
        <view wx:elif="{{view == 'APP'}}"> APP </view>
        <view wx:else="{{view == 'MINA'}}"> MINA </view>
      #+end_src

***** 模板
      #+begin_src html
        <template name="staffName">
          <view>
            FirstName: {{firstName}}, LastName: {{lastName}}
          </view>
        </template>

        <template is="staffName" data="{{...staffA}}"></template>
        <template is="staffName" data="{{...staffB}}"></template>
        <template is="staffName" data="{{...staffC}}"></template>
      #+end_src
      #+begin_src js
        Page({
            data: {
                staffA: {firstName: 'Hulk', lastName: 'Hu'},
                staffB: {firstName: 'Shang', lastName: 'You'},
                staffC: {firstName: 'Gideon', lastName: 'Lin'}
            }
        })
      #+end_src

***** 引用模板
      #+begin_src html
        <!-- item.wxml -->
        <template name="item">
          <text>{{text}}</text>
        </template>
      #+end_src
      
      #+begin_src html
        <import src="item.wxml"/>
        <template is="item" data="{{text: 'forbar'}}"/>
      #+end_src

**** WXSS
     为了定义设备的一致性，微信设定死的固定宽度 为 750rpx (响应式像素单位)，在不同宽度要进行换算.
     
***** 样式导入
      #+begin_src css
        /** common.wxss **/
        .small-p {
            padding:5px;
        }

        /** app.wxss **/
        @import "common.wxss";
        .middle-p {
            padding:15px;
        }
      #+end_src

***** 选择器
      | 选择器           | 样例             | 样例描述                                           |
      |------------------+------------------+----------------------------------------------------|
      | .class           | =.intro=         | 选择所有拥有 class="intro" 的组件                  |
      | #id              | =#firstname=     | 选择拥有 id="firstname" 的组件                     |
      | element          | =view=           | 选择所有 view 组件                                 |
      | element, element | =view, checkbox= | 选择所有文档的 view 组件和所有的 checkbox 组件     |
      | ::after          | =view::after=    | 在 view 组件后边插入内容                   content |
      | ::before         | =view::before=   | 在 view 组件前边插入内容                           |

**** WXS
     WXS（WeiXin Script）是小程序的一套脚本语言，结合 =WXML= ，可以构建出页面的结构。
***** 页面渲染
#+begin_src html
          <!--wxml-->
          <wxs module="m1">
          var msg = "hello world";

          module.exports.message = msg;
          </wxs>

          <view> {{m1.message}} </view>
#+end_src

页面输出： hello world

***** 数据处理
#+begin_src js
          Page({
            data: {
              array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
            }
          })
#+end_src

      #+begin_src html
        <!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 -->
        <wxs module="m1">
          var getMax = function(array) {
          var max = undefined;
          for (var i = 0; i < array.length; ++i) {
                              max = max === undefined ?
                              array[i] :
                              (max >= array[i] ? max : array[i]);
            }
            return max;
            }

            module.exports.getMax = getMax;
        </wxs>

        <!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
        <view> {{m1.getMax(array)}} </view>
          #+end_src
      
      页面输出： 5

*** 事件详解
**** 事件分类
     WXML 的冒泡事件列表：

     | 类型               | 触发条件                                                                                  |
     |--------------------+-------------------------------------------------------------------------------------------|
     | touchstart         | 手指触摸动作开始                                                                          |
     | touchmove          | 手指触摸后移动                                                                            |
     | touchcancel        | 手指触摸动作被打断，如来电提醒，弹窗                                                      |
     | touchend           | 手指触摸动作结束                                                                          |
     | tap                | 手指触摸后马上离开                                                                        |
     | longpress          | 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 |
     | longtap            | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）                              |
     | transitionend      | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发                                 |
     | animationstart     | 会在一个 WXSS animation 动画开始时触发                                                    |
     | animationiteration | 会在一个 WXSS animation 一次迭代结束时触发                                                |
     | animationend       | 会在一个 WXSS animation 动画完成时触发                                                    |
     | touchforcechange   | 在支持 3D Touch 的 iPhone 设备，重按时会触发                                              |

**** 绑定并阻止事件冒泡
     除 =bind= 外，也可以用 =catch= 来绑定事件。与 =bind= 不同， =catch=会阻止事件向上冒泡。

     例如在下边这个例子中，点击 inner view会先后调用=handleTap3=和=handleTap2=(因为
     tap 事件会冒泡到 middle view，而middle view 阻止了 tap 事件冒泡，不再向父节点
     传递)，点击 middle view会触发=handleTap2=，点击 outer view 会触发=handleTap1=。

     #+begin_src html
         <view id="outer" bindtap="handleTap1">
           outer view
           <view id="middle" catchtap="handleTap2">
             middle view
             <view id="inner" bindtap="handleTap3">
               inner view
             </view>
           </view>
         </view>
     #+end_src
**** 互斥事件绑定
     自基础库版本 [[../../compatibility.html][2.8.2]] 起，除 =bind= 和=catch= 外，还可以使用 =mut-bind= 来绑定事
     件。一个 =mut-bind=触发后，如果事件冒泡到其他节点上，其他节点上的 =mut-bind=绑
     定函数不会被触发，但 =bind= 绑定函数和 =catch= 绑定函数依旧会被触发。

     换而言之，所有 =mut-bind=是“互斥”的，只会有其中一个绑定函数被触发。同时，它
     完全不影响 =bind= 和=catch= 的绑定效果。

     例如在下边这个例子中，点击 inner view 会先后调用 =handleTap3= 和
     =handleTap2= ，点击 middle view 会调用 =handleTap2= 和 =handleTap1= 。

     #+BEGIN_EXAMPLE
         <view id="outer" mut-bind:tap="handleTap1">
           outer view
           <view id="middle" bindtap="handleTap2">
             middle view
             <view id="inner" mut-bind:tap="handleTap3">
               inner view
             </view>
           </view>
         </view>
     #+END_EXAMPLE

**** 事件对象

     如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

     *BaseEvent 基础事件对象属性列表：*

     | 属性          | 类型    | 说明                           |
     |---------------+---------+--------------------------------|
     | [[index_u100.html#type][type]]          | String  | 事件类型                       |
     | [[index_u100.html#timeStamp][timeStamp]]     | Integer | 事件生成时的时间戳             |
     | [[index_u100.html#target][target]]        | Object  | 触发事件的组件的一些属性值集合 |
     | [[index_u100.html#currenttarget][currentTarget]] | Object  | 当前组件的一些属性值集合       |
     | [[index_u100.html#mark][mark]]          | Object  | 事件标记数据                   |
 
     *CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：*

     | 属性                                 | 类型     | 说明         |
     |--------------------------------------+----------+--------------|
     | [[index_u100.html#detail][detail]]   | Object   | 额外的信息   |

     *TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：*
     | 属性                                                 | 类型    | 说明                                           |
     |------------------------------------------------------+---------+------------------------------------------------|
     | [[index_u100.html#touches][touches]]                 | Array   | 触摸事件，当前停留在屏幕中的触摸点信息的数组   |
     | [[index_u100.html#changedTouches][changedTouches]]   | Array   | 触摸事件，当前变化的触摸点信息的数组           |

     *特殊事件： [[../../../component/canvas.html][canvas]]
     中的触摸事件不可冒泡，所以没有 currentTarget。*

*** 简易双向绑定
**** 双向绑定语法
      #+begin_src html
         <input model:value="{{value}}" />
      #+end_src

**** 在自定义组件中传递双向绑定
     双向绑定同样可以使用在自定义组件上。如下的自定义组件：
     #+begin_src js
         // custom-component.js
         Component({
           properties: {
             myValue: String
           }
         })
     #+end_src
#+begin_src html
  <!-- custom-component.wxml -->
  <input model:value="{{myValue}}" />
#+end_src
     这个自定义组件将自身的 =myValue= 属性双向绑定到了组件内输入框的 =value=属性上。
     这样，如果页面这样使用这个组件：
#+begin_src html
  <custom-component model:my-value="{{pageValue}}" />
#+end_src

**** 在自定义组件中触发双向绑定更新

     自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData设置自身的属性。
#+begin_src js
  // custom-component.js
  Component({
      properties: {
          myValue: String
      },
      methods: {
          update: function() {
              // 更新 myValue
              this.setData({
                  myValue: 'leaf'
              })
          }
      }
  })
  #+end_src

如果页面这样使用这个组件：

#+begin_src html
  <custom-component model:my-value="{{pageValue}}" />
#+end_src

     当组件使用 =setData= 更新 =myValue= 时，页面的 =this.data.pageValue=也会同时变
     更，页面 WXML 中所有绑定了 =pageValue= 的位置也会被一同更新。

*** 组件属性

    | 属性名         | 类型         | 描述           | 注解                                     |
    |----------------+--------------+----------------+------------------------------------------|
    | id             | String       | 组件的唯一标示 | 保持整个页面唯一                         |
    | class          | String       | 组件的样式类   | 在对应的 WXSS 中定义的样式类             |
    | style          | String       | 组件的内联样式 | 可以动态设置的内联样式                   |
    | hidden         | Boolean      | 组件是否显示   | 所有组件默认显示                         |
    | data-*         | Any          | 自定义属性     | 组件上触发的事件时，会发送给事件处理函数 |
    | bind* / catch* | EventHandler | 组件的事件     | 详见[[file:wxml/event.html][事件]]                                 |

*** 获取界面上的节点信息
**** WXML 节点信息
     [[../../api/wxml/wx.createSelectorQuery.html][节点信息查询 API]]可以用于获取节点属性、样式、在界面上的位置等信息。

     最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

     *示例代码：*
#+begin_src js
         const query = wx.createSelectorQuery()
         query.select('#the-id').boundingClientRect(function(res){
           res.top // #the-id 节点的上边界坐标（相对于显示区域）
         })
         query.selectViewport().scrollOffset(function(res){
           res.scrollTop // 显示区域的竖直滚动位置
         })
         query.exec()
#+end_src

     上述示例中， =#the-id= 是一个节点选择器，与 CSS的选择器相近但略有区别，请参见
     [[../../api/wxml/SelectorQuery.select.html][SelectorQuery.select]]的相关说明。

     在自定义组件或包含自定义组件的页面中，推荐使用
     =this.createSelectorQuery= 来代替
     [[../../api/wxml/wx.createSelectorQuery.html][wx.createSelectorQuery]]
     ，这样可以确保在正确的范围内选择节点。

**** WXML 节点布局相交状态

     [[../../api/wxml/wx.createIntersectionObserver.html][节点布局相交状态API]]可用于监听两个或多个组件节点在布局位置上的相交状态。这一组
     API 常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。

     这一组 API 涉及的主要概念如下。

     -  参照节点：监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的
       *交集* 作为参照区域。页面显示区域也可作为参照区域之一。
     -  目标节点：监听的目标，默认只能是一个节点（使用 =selectAll=
       选项时，可以同时监听多个节点）。
     -  相交区域：目标节点的布局区域与参照区域的相交区域。
     -  相交比例：相交区域占参照区域的比例。
     -  阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。

     以下示例代码可以在目标节点（用选择器 =.target-class=
     指定）每次进入或离开页面显示区域时，触发回调函数。

     *示例代码：*
#+begin_src js
  Page({
      onLoad: function(){
          wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
              res.id // 目标节点 id
              res.dataset // 目标节点 dataset
              res.intersectionRatio // 相交区域占目标节点的布局区域的比例
              res.intersectionRect // 相交区域
              res.intersectionRect.left // 相交区域的左边界坐标
              res.intersectionRect.top // 相交区域的上边界坐标
              res.intersectionRect.width // 相交区域的宽度
              res.intersectionRect.height // 相交区域的高度
          })
      }
  })
         #+end_src

     以下示例代码可以在目标节点（用选择器 =.target-class=指定）与参照节点（用选择器
     =.relative-class=指定）在页面显示区域内相交或相离，且相交或相离程度达到目标节
     点布局区域的 20%和 50%时，触发回调函数。

     *示例代码：*

     #+BEGIN_EXAMPLE
         Page({
           onLoad: function(){
             wx.createIntersectionObserver(this, {
               thresholds: [0.2, 0.5]
             }).relativeTo('.relative-class').relativeToViewport().observe('.target-class', (res) => {
               res.intersectionRatio // 相交区域占目标节点的布局区域的比例
               res.intersectionRect // 相交区域
               res.intersectionRect.left // 相交区域的左边界坐标
               res.intersectionRect.top // 相交区域的上边界坐标
               res.intersectionRect.width // 相交区域的宽度
               res.intersectionRect.height // 相交区域的高度
             })
           }
         })
     #+END_EXAMPLE

     注意：与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是
     “布局区域”，布局区域可能会在绘制时被其他节点裁剪隐藏（如遇祖先节点中overflow
     样式为 hidden 的节点）或遮盖（如遇 fixed 定位的节点）。

     在自定义组件或包含自定义组件的页面中，推荐使用
     =this.createIntersectionObserver= 来代替[[../../api/wxml/wx.createIntersectionObserver.html][wx.createIntersectionObserver]]，这样可
     以确保在正确的范围内选择节点。

*** 动画
**** 界面动画的常见方式
     在小程序中，通常可以使用 CSS渐变和CSS动画 来创建简易的界面动画。

     动画过程中，可以使用 =bindtransitionend= =bindanimationstart=
     =bindanimationiteration= =bindanimationend= 来监听动画事件。

     | 事件名               | 含义                                                                                                 |
     |----------------------+------------------------------------------------------------------------------------------------------|
     | transitionend        | CSS 渐变结束或 [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]] 结束一个阶段   |
     | animationstart       | CSS 动画开始                                                                                         |
     | animationiteration   | CSS 动画结束一个阶段                                                                                 |
     | animationend         | CSS 动画结束                                                                                         |

     注意：这几个事件都不是冒泡事件，需要绑定在真正发生了动画的节点上才会生效。

**** 关键帧动画

     从小程序基础库 [2.9.0]]开始支持一种更友好的动画创建方式，用于代替旧的 wx.createAnimation。它具有更好的性能和更可控的接口。

     在页面或自定义组件中，当需要进行关键帧动画时，可以使用 =this.animate= 接口：

     #+BEGIN_EXAMPLE
         this.animate(selector, keyframes, duration, callback)
     #+END_EXAMPLE

     *参数说明*

     | 属性      | 类型     | 默认值 | 必填 | 说明                       |
     | keyframes | Array    |        | 是   | 关键帧信息                 |
     | duration  | Number   |        | 是   | 动画持续时长（毫秒为单位） |
     | callback  | function |        | 否   | 动画完成后的回调函数       |

     *keyframes 中对象的结构*

     | 属性            | 类型          | 默认值 | 必填                              | 说明                                    |
     |-----------------+---------------+--------+-----------------------------------+-----------------------------------------|
     | offset          | Number        |        | 否                                | 关键帧的偏移，范围[0-1]                 |
     | ease            | String        | linear | 否                                | 动画缓动函数                            |
     | transformOrigin | String        | 否     | 基点位置，即 CSS transform-origin |                                         |
     | backgroundColor | String        |        | 否                                | 背景颜色，即 CSS background-color       |
     | bottom          | Number/String |        | 否                                | 底边位置，即 CSS bottom                 |
     | height          | Number/String |        | 否                                | 高度，即 CSS height                     |
     | left            | Number/String |        | 否                                | 左边位置，即 CSS left                   |
     | width           | Number/String |        | 否                                | 宽度，即 CSS width                      |
     | opacity         | Number        |        | 否                                | 不透明度，即 CSS opacity                |
     | right           | Number        |        | 否                                | 右边位置，即 CSS right                  |
     | top             | Number/String |        | 否                                | 顶边位置，即 CSS top                    |
     | matrix          | Array         |        | 否                                | 变换矩阵，即 CSS transform matrix       |
     | matrix3d        | Array         |        | 否                                | 三维变换矩阵，即 CSS transform matrix3d |
     | rotate          | Number        |        | 否                                | 旋转，即 CSS transform rotate           |
     | rotate3d        | Array         |        | 否                                | 三维旋转，即 CSS transform rotate3d     |
     | rotateX         | Number        |        | 否                                | X 方向旋转，即 CSS transform rotateX    |
     | rotateY         | Number        |        | 否                                | Y 方向旋转，即 CSS transform rotateY    |
     | rotateZ         | Number        |        | 否                                | Z 方向旋转，即 CSS transform rotateZ    |
     | scale           | Array         |        | 否                                | 缩放，即 CSS transform scale            |
     | scale3d         | Array         |        | 否                                | 三维缩放，即 CSS transform scale3d      |
     | scaleX          | Number        |        | 否                                | X 方向缩放，即 CSS transform scaleX     |
     | scaleY          | Number        |        | 否                                | Y 方向缩放，即 CSS transform scaleY     |
     | scaleZ          | Number        |        | 否                                | Z 方向缩放，即 CSS transform scaleZ     |
     | skew            | Array         |        | 否                                | 倾斜，即 CSS transform skew             |
     | skewX           | Number        |        | 否                                | X 方向倾斜，即 CSS transform skewX      |
     | skewY           | Number        |        | 否                                | Y 方向倾斜，即 CSS transform skewY      |
     | translate       | Array         |        | 否                                | 位移，即 CSS transform translate        |
     | translate3d     | Array         |        | 否                                | 三维位移，即 CSS transform translate3d  |
     | translateX      | Number        |        | 否                                | X 方向位移，即 CSS transform translateX |
     | translateY      | Number        |        | 否                                | Y 方向位移，即 CSS transform translateY |
     | translateZ      | Number        |        | 否                                | Z 方向位移，即 CSS transform translateZ |
**** 滚动驱动的动画

     我们发现，根据滚动位置而不断改变动画的进度是一种比较常见的场景，这类动画可以让人感觉到界面交互很连贯自然，体验更好。因此，从小程序基础库
     [[../compatibility.html][2.9.0]] 开始支持一种由滚动驱动的动画机制。

     基于上述的关键帧动画接口，新增一个 =ScrollTimeline= 的参数，用来绑定滚动元素（目前只支持 scroll-view）。接口定义如下：

     #+BEGIN_EXAMPLE
         this.animate(selector, keyframes, duration, ScrollTimeline)
     #+END_EXAMPLE

     *ScrollTimeline 中对象的结构*
     | 属性                | 类型     | 默认值     | 必填   | 说明                                                                                              |
     |---------------------+----------+------------+--------+---------------------------------------------------------------------------------------------------|
     | scrollSource        | String   |            | 是     | 指定滚动元素的选择器（只支持 scroll-view），该元素滚动时会驱动动画的进度                          |
     | orientation         | String   | vertical   | 否     | 指定滚动的方向。有效值为 horizontal 或 vertical                                                   |
     | startScrollOffset   | Number   |            | 是     | 指定开始驱动动画进度的滚动偏移量，单位 px                                                         |
     | endScrollOffset     | Number   |            | 是     | 指定停止驱动动画进度的滚动偏移量，单位 px                                                         |
     | timeRange           | Number   |            | 是     | 起始和结束的滚动范围映射的时间长度，该时间可用于与关键帧动画里的时间 (duration) 相匹配，单位 ms   |

**** 示例代码

     #+BEGIN_EXAMPLE
           this.animate('.avatar', [{
             borderRadius: '0',
             borderColor: 'red',
             transform: 'scale(1) translateY(-20px)',
             offset: 0,
           }, {
             borderRadius: '25%',
             borderColor: 'blue',
             transform: 'scale(.65) translateY(-20px)',
             offset: .5,
           }, {
             borderRadius: '50%',
             borderColor: 'blue',
             transform: `scale(.3) translateY(-20px)`,
             offset: 1
           }], 2000, {
             scrollSource: '#scroller',
             timeRange: 2000,
             startScrollOffset: 0,
             endScrollOffset: 85,
           })

           this.animate('.search_input', [{
             opacity: '0',
             width: '0%',
           }, {
             opacity: '1',
             width: '100%',
           }], 1000, {
             scrollSource: '#scroller',
             timeRange: 1000,
             startScrollOffset: 120,
             endScrollOffset: 252
           })
     #+END_EXAMPLE

*** 初始渲染缓存
**** 支持的组件
     - view 
     - text
     - button
     - image
     - scroll-view
     - rich-text 

**** 静态初始渲染缓存
     #+begin_src js
        {
           "window": {
             "initialRenderingCache": "static"
           }
         }
     #+end_src

**** 在初始渲染缓存中添加动态内容(开销相对较大)
     #+begin_src js
        {
           "initialRenderingCache": "dynamic"
         }
     #+end_src

     此时，初始渲染缓存不会被自动启用，还需要在页面中调用 =this.setInitialRenderingCache(dynamicData)= 才能启用。其中，
     =dynamicData= 是一组数据，与 =data= 一起参与页面 WXML 渲染。
     #+begin_src js
         Page({
           data: {
             loading: true
           },
           onReady: function() {
             this.setInitialRenderingCache({
               loadingHint: '正在加载' // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
             })
           }
         })
     #+end_src

#+begin_src html
         <view wx:if="{{loading}}">{{loadingHint}}</view>
#+end_src

     -  =this.setInitialRenderingCache= 调用时机不能早于 =Page= 的 =onReady= 或 =Component= 的 =ready= 生命周期，否则可能对性能有负面影响。
     -  如果想禁用初始渲染缓存，调用 =this.setInitialRenderingCache(null)= 。

** 实现页面跳转
   #+begin_src  js
     // js跳转页面
     wx.navigateTo({
         url: `/pages/my/appointDetail/index?_id=${ this .data.marker.id}`
     }) 

     //路由传参如何接收 
     onLoad: function (options) {
         　　 console.log(options)
     },

   #+end_src

* wx.request 的封装
   在 utils 中新建 request.js，简单封装了一下，一些数据要全局配置的都引进来，然
   后做了些错误的统一处理，没什么难度， 不过要特别注意一下 cookie 的携带。具体代
   码如下：
#+begin_src js
       const app =  getApp()
       export  default  function request(url, options =  {}) {
          return  new Promise( function  (resolve, reject) {
           wx.request({
             url: `${app.origin}${url}`,
             method: 'GET' ,
             ...options,
             data: options.data,
             header: {
               'content-type': 'application/json' ,
               'cookie': wx.getStorageSync("cookie" )
             },
             success:  function  (res) {
                // 重新授权登录
                if (res.statusCode === 401 ){ 
                 wx.redirectTo({url: '/pages/login/index' })
                  return 
               } else  if (res.statusCode !== 200 ) { 
                 reject({ error: '服务器忙，请稍后重试', code: 500  });
                  return 
               }  else  {
                  if (url === '/api/cdz/user/weixin/login' ) {
                   const cookie = res.header["set-cookie" ] || res.header["Set-Cookie"]; 
       　　　　　　　　
                    if (cookie) wx.setStorageSync("cookie" , cookie);
                 }
                 resolve(res.data);
               }
             },
             fail:  function  (res) {
                //  fail调用接口失败
                if (url === '/api/cdz/user/weixin/login' ) {
                 const cookie = res.header["set-cookie" ] || res.header["Set-Cookie"];
                  if (cookie) wx.setStorageSync("cookie" , cookie);
               } 
               reject({ error: '网络错误', code: 0  });
             }
           })
         })
       }
       
#+end_src
   然后我们使用的时候直接使用封装好的 request 方法，这样所有的 api 就封装成一个个函数。我们在页面中直接 import 引入调用即可。
#+begin_src js
       import request from "../utils/request" ;
       import { stringify } from "../utils/util" 

       export  function  testPost(data) {
          return request(`/api/test/post`, {
           method: 'PUT' ,
           data,
         })
       }

       export  function  testGet(data) {
          return request(`/api/test/get`)
       }
#+end_src

* 组件和 api
** 组件
*** 标签
    - view
      - hover-class 指定按下去的样式类 (点击效果)
      - hover-start-time 按住后多久出现点击态，单位毫秒 50
      - hover-stay-time	number	手指松开后点击态保留时间，单位毫秒	400		
    - scroll-view(https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html)
    - [swiper](https://mp.weixin.qq.com/debug/wxadoc/dev/component/swiper.html)
    滑块视图容器。其中只可放置swiper-item组件，否则会导致未定义的行为

    - [icon](https://mp.weixin.qq.com/debug/wxadoc/dev/component/icon.html)
    - [text](https://mp.weixin.qq.com/debug/wxadoc/dev/component/text.html)
    - [progress](https://mp.weixin.qq.com/debug/wxadoc/dev/component/progress.html)

*** 表单组件
    - [button](https://mp.weixin.qq.com/debug/wxadoc/dev/component/button.html)
    - [checkbox](https://mp.weixin.qq.com/debug/wxadoc/dev/component/checkbox.html)
    - [form](https://mp.weixin.qq.com/debug/wxadoc/dev/component/form.html)
    - [input](https://mp.weixin.qq.com/debug/wxadoc/dev/component/input.html)
    - [label](https://mp.weixin.qq.com/debug/wxadoc/dev/component/label.html)
    - [picker](https://mp.weixin.qq.com/debug/wxadoc/dev/component/picker.html)
    - [radio](https://mp.weixin.qq.com/debug/wxadoc/dev/component/radio.html)
    - [slider](https://mp.weixin.qq.com/debug/wxadoc/dev/component/slider.html)
    - [switch](https://mp.weixin.qq.com/debug/wxadoc/dev/component/switch.html)
    - [textarea](https://mp.weixin.qq.com/debug/wxadoc/dev/component/textarea.html)

*** 导航
    - [navigator](https://mp.weixin.qq.com/debug/wxadoc/dev/component/navigator.html)

*** 媒体组件
    - [audio](https://mp.weixin.qq.com/debug/wxadoc/dev/component/audio.html)
    - [image](https://mp.weixin.qq.com/debug/wxadoc/dev/component/image.html)
    - [video](https://mp.weixin.qq.com/debug/wxadoc/dev/component/video.html)

      #+begin_src html
      	<image class="" src="{{imagePath}}" mode="aspectFill" lazy-load="false" binderror="" bindload="">
      #+end_src
       mode 指定图片的显示模式 
       
*** 地图
    - [map](https://mp.weixin.qq.com/debug/wxadoc/dev/component/map.html%20#map)

*** 画布
    - [canvas](https://mp.weixin.qq.com/debug/wxadoc/dev/component/canvas.html)

*** 客服会话
    - [contact-button](https://mp.weixin.qq.com/debug/wxadoc/dev/component/contact-button.html)

** api(https://mp.weixin.qq.com/debug/wxadoc/dev/api/)
*** [网络](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-network.html)
**** [发起请求](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html)
     - `wx.request`   `wx.request` 发起的是 HTTPS 请求
**** [上传、下载](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-file.html)
     - `wx.uploadFile`   将本地资源上传到开发者服务器
     - `wx.downloadFile` 下载文件资源到本地
**** [WebSocket](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)
     - `wx.connectSocket`  创建一个 WebSocket 连接
     - `wx.onSocketOpen`   监听 WebSocket 连接打开事件
     - `wx.onSocketError`  监听 WebSocket 错误
     - `wx.sendSocketMessage`  通过 WebSocket 连接发送数据
     - `wx.onSocketMessage`  监听 WebSocket 接受到服务器的消息事件
     - `wx.closeSocket`    关闭 WebSocket 连接
     - `wx.onSocketClose`  监听 WebSocket 关闭
*** [媒体](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-picture.html)
**** [图片](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-picture.html)

     - `wx.chooseImage`  从本地相册选择图片或使用相机拍照
     - `wx.previewImage` 预览图片
     - `wx.getImageInfo` 获取图片信息
**** [录音](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-record.html)

     - `wx.startRecord`  开始录音
     - `wx.stopRecord`   主动调用停止录音
**** [音频播放控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-voice.html)

     - `wx.playVoice`    开始播放语音
     - `wx.pauseVoice`   暂停正在播放的语音
     - `wx.stopVoice`    结束播放语音
**** [音乐播放控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-background-audio.html)

     - `wx.getBackgroundAudioPlayerState`  获取音乐播放状态
     - `wx.playBackgroundAudio`  播放音乐，同时只能有一首音乐正在播放
     - `wx.pauseBackgroundAudio` 暂停播放音乐
     - `wx.seekBackgroundAudio`  控制音乐播放进度
     - `wx.stopBackgroundAudio`  停止播放音乐
     - `wx.onBackgroundAudioPlay`  监听音乐播放
     - `wx.onBackgroundAudioPause` 监听音乐暂停
     - `wx.onBackgroundAudioStop`  监听音乐停止
**** [音频组件控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

     - `wx.createAudioContext` 创建并返回 audio 上下文 `audioContext` 对象
**** [视频](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

     - `wx.chooseVideo`  拍摄视频或从手机相册中选视频，返回视频的临时文件路径
**** [视频组件控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

     - `wx.createVideoContext`  创建并返回 video 上下文 `videoContext` 对象
*** [文件](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)
    - `wx.saveFile` 保存文件到本地
    - `wx.getSavedFileList` 获取本地已保存的文件列表
    - `wx.getSavedFileInfo` 获取本地文件的文件信息
    - `wx.removeSavedFile` 删除本地存储的文件
    - `wx.openDocument` 新开页面打开文档，支持格式：doc, xls, ppt, pdf, docx, xlsx, pptx
*** [数据缓存](https://mp.weixin.qq.com/debug/wxadoc/dev/api/data.html)

    - `wx.setStorage`   将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口
    - `wx.setStorageSync` 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口
    - `wx.getStorage`  从本地缓存中异步获取指定 key 对应的内容
    - `wx.getStorageSync` 从本地缓存中同步获取指定 key 对应的内容
    - `wx.getStorageInfo` 异步获取当前 storage 的相关信息
    - `wx.getStorageInfoSync` 同步获取当前 storage 的相关信息
    - `wx.removeStorage`  从本地缓存中异步移除指定 key
    - `wx.removeStorageSync`  从本地缓存中同步移除指定 key
    - `wx.clearStorage` 清理本地数据缓存
    - `wx.clearStorageSync` 同步清理本地数据缓存
*** [位置](https://mp.weixin.qq.com/debug/wxadoc/dev/api/location.html)
**** 获取位置
     - `wx.getLocation` 获取当前的地理位置、速度
     - `wx.chooseLocation` 打开地图选择位置
**** 查看位置
     - `wx.openLocation` 使用微信内置地图查看位置
**** [地图组件控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-map.html)

     - `wx.createMapContext` 创建并返回 map 上下文 mapContext 对象
*** [设备](https://mp.weixin.qq.com/debug/wxadoc/dev/api/device.html)
**** [系统信息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/systeminfo.html)

     - `wx.getSystemInfo` 获取系统信息
     - `wx.getSystemInfoSync` 获取系统信息同步接口
**** [网络状态](https://mp.weixin.qq.com/debug/wxadoc/dev/api/device.html)

     - `wx.getNetworkType` 获取网络类型
**** [重力感应](https://mp.weixin.qq.com/debug/wxadoc/dev/api/accelerometer.html)

     - `wx.onAccelerometerChange`  监听重力感应数据，频率：5次/秒
**** [罗盘](https://mp.weixin.qq.com/debug/wxadoc/dev/api/campass.html)

     - `wx.onCompassChange`  监听罗盘数据，频率：5次/秒
**** [拨打电话](https://mp.weixin.qq.com/debug/wxadoc/dev/api/phonecall.html)

     - `wx.makePhoneCall`  拨打电话
**** [扫码](https://mp.weixin.qq.com/debug/wxadoc/dev/api/scancode.html)

     - `wx.scanCode` 调起客户端扫码界面，扫码成功后返回对应的结果
*** [界面](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-react.html)
**** [交互反馈](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-react.html)

     - `wx.showToast` 显示消息提示框
     - `wx.hideToast` 隐藏消息提示框
     - `wx.showModal` ​显示模态弹窗
     - `wx.showActionSheet` 显示操作菜单
**** [设置导航条](https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui.html)

     - `wx.setNavigationBarTitle` 动态设置当前页面的标题
     - `wx.showNavigationBarLoading` 在当前页面显示导航条加载动画
     - `wx.hideNavigationBarLoading` 隐藏导航条加载动画
**** [导航](https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html)

     - `wx.navigateTo`  保留当前页面，跳转到应用内的某个页面，使用 `wx.navigateBack` 可以返回到原页面
     - `wx.redirectTo` 关闭当前页面，跳转到应用内的某个页面
     - `wx.switchTab`  跳转到 `tabBar` 页面，并关闭其他所有非 `tabBar` 页面
     - `wx.navigateBack`  关闭当前页面，返回上一页面或多级页面。可通过 `getCurrentPages()` 获取当前的页面栈，决定需要返回几层
**** [动画](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-animation.html)

     - `wx.createAnimation`  创建一个动画实例 `animation`。调用实例的方法来描述动画。最后通过动画实例的`export` 方法导出动画数据传递给组件的 `animation` 属性。
     - animation
     - 动画队列
**** [绘图](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/intro.html)

     - [简介 intro](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/intro.html)
     - [Canvas 坐标系](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/coordinates.html)
     - [渐变](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/gradient.html)
     - [API 接口索引](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/reference.html)
     - [wx.createCanvasContext](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/create-canvas-context.html) 创建 canvas 绘图上下文（指定 canvasId）
     - [wx.canvasToTempFilePath](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/reference.html) 把当前画布的内容导出生成图片，并返回文件路径
**** [下拉刷新](https://mp.weixin.qq.com/debug/wxadoc/dev/api/pulldown.html)

     - `Page.onPullDownRefresh` 在 `Page` 中定义 `onPullDownRefresh` 处理函数，监听该页面用户下拉刷新事件
     - `wx.stopPullDownRefresh` 停止当前页面下拉刷新
*** [开放接口](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html)
**** [登录](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html)
     - `wx.login` 调用接口获取登录凭证（code）进而换取用户登录态信息
     - `code` 换取 `session_key`
     - 登录态维护
       - 登录时序图
       - `wx.checkSession` 检查登陆态是否过期
     - [用户数据的签名验证和加解密](https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html)
       - 数据签名校验
       - 加密数据解密算法
**** [用户信息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/open.html)
     - `wx.getUserInfo` 获取用户信息，需要先调用 `wx.login` 接口说明
     - `UnionID` 机制说明
**** [微信支付](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html)

     - `wx.requestPayment` 发起微信支付
**** [模板消息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/notice.html)

     - 使用说明
     - 接口说明
       - 获取 access_token
       - 发送模板消息
       - 下发条件说明
       - 审核说明
       - 违规说明
       - 处罚说明
**** 客服消息
     - [接收消息和事件](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/receive.html)
       - 文本消息
       - 图片消息
       - 进入会话事件
     - [发送客服消息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/conversation.html)
     - [临时素材接口](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/material.html)
       - 获取临时素材
       - 新增临时素材
     - [接入指引](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/callback_help.html)
**** [分享](https://mp.weixin.qq.com/debug/wxadoc/dev/api/share.html)

     - Page.onShareAppMessage
*** 基础
**** wx.canIUse 
     判断小程序的API，回调，参数，组件等是否在当前版本可用。

     参数
     string schema
     使用 ${API}.${method}.${param}.${option} 或者 ${component}.${attribute}.${option} 方式来调用
***** 参数说明
      ${API} 代表 API 名字
      ${method} 代表调用方式，有效值为return, success, object, callback
      ${param} 代表参数或者返回值
      ${option} 代表参数的可选值或者返回值的属性
      ${component} 代表组件名字
      ${attribute} 代表组件属性
      ${option} 代表组件属性的可选值
***** 示例代码
      // 对象的属性或方法
      wx.canIUse('console.log')
      wx.canIUse('CameraContext.onCameraFrame')
      wx.canIUse('CameraFrameListener.start')
      wx.canIUse('Image.src')

      // wx接口参数、回调或者返回值
      wx.canIUse('openBluetoothAdapter')
      wx.canIUse('getSystemInfoSync.return.safeArea.left')
      wx.canIUse('getSystemInfo.success.screenWidth')
      wx.canIUse('showToast.object.image')
      wx.canIUse('onCompassChange.callback.direction')
      wx.canIUse('request.object.method.GET')

      // 组件的属性
      wx.canIUse('live-player')
      wx.canIUse('text.selectable')
      wx.canIUse('button.open-type.contact')

*** 开放接口
**** 登录
     wx.login
     wx.checkSession
**** 小程序跳转
     wx.navigateToMiniProgram
     wx.navigateBackMiniProgram
**** 帐号信息
     wx.getAccountInfoSync
**** 用户信息
     wx.getUserInfo
     UserInfo
**** 数据上报
     wx.reportMonitor
**** 数据分析
     wx.reportAnalytics
**** 支付
     wx.requestPayment
**** 授权
     wx.authorize
**** 设置
     wx.openSetting
     wx.getSetting
     AuthSetting
     SubscriptionsSetting
**** 收货地址
     wx.chooseAddress
**** 卡券
     wx.openCard
     wx.addCard
**** 发票
     wx.chooseInvoiceTitle
     wx.chooseInvoice
**** 生物认证
     wx.startSoterAuthentication
     wx.checkIsSupportSoterAuthentication
     wx.checkIsSoterEnrolledInDevice
**** 微信运动
     wx.getWeRunData
**** 性能
     wx.reportPerformance
     wx.getPerformance
***** EntryList
      EntryList.getEntries
      EntryList.getEntriesByName
      EntryList.getEntriesByType
***** Performance
      Performance.createObserver
      Performance.getEntries
      Performance.getEntriesByName
      Performance.getEntriesByType
      Performance.setBufferSize
***** PerformanceObserver
      PerformanceObserver.disconnect
      PerformanceObserver.observe
**** 订阅消息
     wx.requestSubscribeMessage
**** 微信红包
     wx.showRedPackage
**** 群工具
     wx.getGroupEnterInfo

* 事件
** 事件类型 
   - tap：触摸后马上离开。
   - longpress：触摸后，超过 350ms 再离开。如果指定了该事件的回调函数并触发了该事件，tap事件将不被触发。
   - touchstart：触摸开始。
   - touchmove：触摸后移动。
   - touchcancel：触摸动作被打断，如来电提醒，弹窗等。
   - touchend：触摸结束。
   - 
   -
** 屏幕旋转事件     
  #+begin_src js
    Page({
        onResize(res) {
            res.size.windowWidth // 新的显示区域宽度
            res.size.windowHeight // 新的显示区域高度
        }
    })
  #+end_src

** 事件属性
   - capture-bind：捕获阶段触发。
   - capture-catch：捕获阶段触发，并中断事件，不再向下传播，即中断捕获阶段，并取消随后的冒泡阶段。
   - bind：冒泡阶段触发。
   - catch：冒泡阶段触发，并取消事件进一步向上冒泡。

* WXML语法  
** 数据绑定 
*** 控制属性
    <view wx:if="{{condition}}"> </view>
*** 三元运算
    <view hidden="{{flag ? true : false}}"> Hidden </view>
*** 算数运算
    <view> {{a + b}} + {{c}} + d </view>
*** 逻辑判断
    <view wx:if="{{length > 5}}"> </view>
*** 字符串运算
    <view>{{"hello" + name}}</view>
*** 数组
    <view wx:for="{{[zero, 1, 2, 3, 4]}}"> {{item}} </view>
*** 对象
    <template is="objectCombine" data="{{for: a, bar: b}}"></template>
*** 也可以用扩展运算符 ... 来将一个对象展开
    <template is="objectCombine" data="{{...obj1, ...obj2, e: 5}}"></template>
** 列表渲染
*** wx:for
    在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。

    默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item
#+begin_src html
    <view wx:for="{{array}}">
    {{index}}: {{item.message}}
    </view>
#+end_src
#+begin_src js
  Page({
      data: {
          array: [{
              message: 'foo',
          }, {
              message: 'bar'
          }]
      }
  })

    #+end_src
使用 wx:for-item 可以指定数组当前元素的变量名，

    使用 wx:for-index 可以指定数组当前下标的变量名：
#+begin_src html
    <view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
    {{idx}}: {{itemName.message}}
    </view>
#+end_src
    wx:for 也可以嵌套，下边是一个九九乘法表
    #+begin_src html
    <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
    <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    <view wx:if="{{i <= j}}">
    {{i}} * {{j}} = {{i * j}}
    </view>
    </view>
    </view>
    #+end_src
    block wx:for
    类似 block wx:if，也可以将 wx:for 用在<block/>标签上，以渲染一个包含多节点的结构块。例如：
#+begin_src html
    <block wx:for="{{[1, 2, 3]}}">
    <view> {{index}}: </view>
    <view> {{item}} </view>
    </block>
#+end_src
*** wx:key
    如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目
    保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用
    wx:key 来指定列表中项目的唯一的标识符。

    wx:key 的值以两种形式提供

    字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
    保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。
 
    当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新
    排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

    如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。

    示例代码：
#+begin_src html
    <switch wx:for="{{objectArray}}" wx:key="unique" style="display: block;"> {{item.id}} </switch>
    <button bindtap="switch"> Switch </button>
    <button bindtap="addToFront"> Add to the front </button>

    <switch wx:for="{{numberArray}}" wx:key="*this" style="display: block;"> {{item}} </switch>
    <button bindtap="addNumberToFront"> Add to the front </button>
#+end_src
#+begin_src js
  Page({
      data: {
          objectArray: [
              {id: 5, unique: 'unique_5'},
              {id: 4, unique: 'unique_4'},
              {id: 3, unique: 'unique_3'},
              {id: 2, unique: 'unique_2'},
              {id: 1, unique: 'unique_1'},
              {id: 0, unique: 'unique_0'},
          ],
          numberArray: [1, 2, 3, 4]
      },
      switch: function(e) {
          const length = this.data.objectArray.length
          for (let i = 0; i < length; ++i) {
              const x = Math.floor(Math.random() * length)
              const y = Math.floor(Math.random() * length)
              const temp = this.data.objectArray[x]
              this.data.objectArray[x] = this.data.objectArray[y]
              this.data.objectArray[y] = temp
          }
          this.setData({
              objectArray: this.data.objectArray
          })
      },
      addToFront: function(e) {
          const length = this.data.objectArray.length
          this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)
          this.setData({
              objectArray: this.data.objectArray
          })
      },
      addNumberToFront: function(e){
          this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
          this.setData({
              numberArray: this.data.numberArray
          })
      }
  })

    #+end_src
    注意：

    当 wx:for 的值为字符串时，会将字符串解析成字符串数组
#+begin_src html
    <view wx:for="array">
    {{item}}
    </view>
#+end_src
    等同于

#+begin_src html
    <view wx:for="{{['a','r','r','a','y']}}">
    {{item}}
    </view>
#+end_src
    注意： 花括号和引号之间如果有空格，将最终被解析成为字符串

#+begin_src html
    <view wx:for="{{[1,2,3]}} ">
    {{item}}
    </view>
    
#+end_src
    等同于

#+begin_src html
  <view wx:for="{{[1,2,3] + ' '}}" >
    {{item}}
  </view>
#+end_src

* 页面内容 wxml    
** 文本 <view>
** 图片 <img>  

* 页面路由
** 页面栈
   | 路由方式   | 页面栈表现                        |
   |------------+-----------------------------------|
   | 初始化     | 新页面入栈                        |
   | 打开新页面 | 新页面入栈                        |
   | 页面重定向 | 当前页面出栈，新页面入栈          |
   | 页面返回   | 页面不断出栈，直到目标返回页      |
   | Tab 切换   | 页面全部出栈，只留下新的 Tab 页面 |
   | 重加载     | 页面全部出栈，只留下新的页面      |

   开发者可以使用 =getCurrentPages()= 函数获取当前页面栈。

** 路由方式
   <navigator url="/pages/home/home">home</navigator>
          
   | 打开新页面 | wx.navigateTo        | 组件 <navigator open-type="navigateTo"/>     |
   | 页面重定向 | wx.redirectTo        | 组件 <navigator open-type="redirectTo"/>     |
   | 页面返回   | wx.navigateBack      | 使用组件<navigator open-type="navigateBack"> |
   | Tab 切换   | wx.switchTab         | 使用组件 <navigator open-type="switchTab"/>  |
   | 重启动     | 调用 API wx.reLaunch | 使用组件 <navigator open-type="reLaunch"/>   |

   Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：
  
   | 当前页面          | 路由后页面      | 触发的生命周期（按顺序）                             |
   |-------------------+-----------------+------------------------------------------------------|
   | A                 | A               | Nothing happend                                      |
   | A                 | B               | A.onHide(), B.onLoad(), B.onShow()                   |
   | A                 | B（再次打开）   | A.onHide(), B.onShow()                               |
   | C                 | A               | C.onUnload(), A.onShow()                             |
   | C                 | B               | C.onUnload(), B.onLoad(), B.onShow()                 |
   | D                 | B               | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()   |
   | D（从转发进入）   | A               | D.onUnload(), A.onLoad(), A.onShow()                 |
   | D（从转发进入）   | B               | D.onUnload(), B.onLoad(), B.onShow()                 |

   - =navigateTo=, =redirectTo= 只能打开非 tabBar 页面。
   - =switchTab= 只能打开 tabBar 页面。
   - =reLaunch= 可以打开任意页面。
   - 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有tabBar。
   - 调用页面路由带的参数可以在目标页面的=onLoad=中获取。

* 引入组件      
** 1. component 引入

     #+begin_src json
       {
           "navigationBarTitleText": "结算",
           "usingComponents": {
               "goods-form":"/components/order/order-submit/goods-form/goods-form"
           }
       }
 #+end_src
 再使用
 #+begin_src html
 <goods-form></goods-form>
 #+end_src
** 2.
